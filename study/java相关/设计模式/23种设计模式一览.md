# 创建型的设计模式
- 单例模式
- 工厂模式
- 抽象工厂模式
- 抽象工厂方法
- 建造者模式
- 原型模式（通过复制这个原型来创建新的对象）
- 生成器模式（build出很多东西）

# 结构型的设计模式
结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，

- 外观模式（也称“门面模式”，就是对子系统的封装，对上层暴露出一个门面接口，使得上层不必关心子系统的各种调用过程）
- 适配器模式（将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。）
- 桥接模式（如果一个类也可以有几个独立拓展的维度，那么把这些维度单独抽取出来去做变化，从而使得这个类只持有这几个维度的抽象）
- 代理模式（对某个对象提供一个代理，代理会做出这个对象本身不具备但又不关心的一些功能，比如代理打印。与装饰着模式一样需要实现同个接口，但是强调的东西不同。通常来说更作用于那些我们需要去调用但是不方便直接访问的对象）
- 装饰者模式（不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。强调的是对自身对象功能的增强）
- 享元模式（就是对对象的复用）
- 组合模式（把对象按照类似树一样的结构去看待）

# 行为型的设计模式

- 策略模式
（对算法的封装或者说一种决策的封装，使得把业务的逻辑与具体的算法分离开来，而我们可以根据实际需要去选择相应的算法
 算法之间是平等的、相互独立的，所以才可以自由调换。重心在于怎么组装这些算法，而不是实现）
- 责任链模式
- 状态模式（允许一个对象在其内部状态改变时改变它的行为）
- 命令模式（将某个请求或操作封装成一个对象）
- 观察者模式
- 备忘录模式（保存对象在操作前的一些状态，方便后面可以进行状态的恢复）
- 模板方法模式（定义一个模板，然后按照模版来依样画葫芦）
- 访问者模式（对不同的具体访问者会有不同的访问的效果）
- 中介者模式（又称调停者模式。比较理想，就是A和B不显式交互，而把他们交互的细节放给中介者来调用。使得A与B的依赖能限定在中介者类里面）
- 迭代器模式
- 解释器模式


