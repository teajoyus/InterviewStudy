视频教程：https://www.bilibili.com/video/av29502877/?p=22
博客： 直接百度
https://blog.csdn.net/yhyr_ycy/article/details/52566105

（发音 minor gc（maɪnə(r)）  survivor（səˈvaɪvə(r)） major （meɪdʒə(r)））

## 线程独享与共享区域

JVM划分线程共享和线程独立的区域

线程共享的区域是方法区和java堆


独立的区域是虚拟机栈、本地方法栈、程序计数器

## 各个内存区域的理解

程序计数器：就是指向当前字节码执行到的指令地址（理解为代码的行号），思考：netive方法的时候程序计数器是undefine，为什么是underfine
（程序计数器是java虚拟机规范中唯一一个没有规定任何OutofMemeryError的区域。程序计数器具有线程隔离性，每个线程独占一个计数器）

虚拟机栈：每个方法执行的时候会创建一个栈帧（具体就是存放了局部变量表、操作数栈、动态链接、方法出口等），入栈后方法执行完毕出栈。当栈存放满了又还有栈帧入栈时，就会抛出StactOverFlowError的异常。。

局部变量表：内存空间是在编译期间就已经完成分配的，执行该方法的栈帧需要为这个局部变量表分配多少内存是固定的，运行期间不会改变大小，该内存空间是存放各种基本数据类型、引用对象（指针，注意不是对象内存）、返回值类型。

本地方法栈(**hotspot不区分虚拟机栈和本地方法栈**)：虚拟机栈是提供给java运行方法的服务的，而本地方法栈则是java运行native方法栈服务的

堆内存（共享）：存放对象实例的，垃圾收集器管理的主要区域。分为新生代和老生代。新生代里分了Eden分区（80%）、两块Survivor（各占10%）
（jdk8后 常量池放在了堆里）
（物理空间不要求连续，只需要逻辑空间连续）

方法区（共享）：存储虚拟机加载的类信息（通过ClassLoader）、常量、静态变量。也就是说编译器编译后的代码数据。申请失败的时候则会抛出OutMemoryError
（也被称为永久代，因为在这里发生的gc很少，gc主要针对常量池的回收和已加载类的卸载）

TLAB(thread local allocation buffer) 在eden区域中为每个线程分配的缓冲空间，这样线程可以单独在这里分配对象，避免了线程同时申请空间需要加锁的问题。



## 垃圾回收算法

判断对象是否存活的两个算法：
引用计数法：有引用就累加1，但是如果两个对象相互引用又没被其他对象所持有，则造成泄漏
缺点：泄漏
可达性分析法：设定一个GCRoot往下搜索引用链，判断结点是否可达，不可达则说明没有对象指向它，则是可回收对象
缺点：搜索性能问题、另外一个是线程停止的问题（Stop The World）：在执行分析期间，对象的引用关系不能发生变化，


标记-清除算法：
标记是采用可达性分析发（遍历Root）
清除：把标记了的对象清除掉
考虑的问题：效率问题、空间问题（清理后空间不连续、碎片很多，如果需要申请大内存空间又没有连续的大内存空间用）

复制算法：
把内存划分为两个空间 成为空闲空间和活动空间，各占50%。
对象的使用都放在了活动空间，当发生清理时，把存活的对象按照内存连续依次排列到空闲空间来（此时空闲空间就编程了活动空间），而把原来的活动空间的数据全部刷掉，变成了空闲空间。
这样解决了标记清除算法导致的清理空间后空间碎片太多不连续的问题。
但是带来的另外一个问题是很要命的，就是没了50%的空间
另外一个是极端的问题是假如存活的对象占100%，那么就需要把所有的对象都复制一遍，并且修改引用地址。这个时间开销是非常多的



标记-整理算法
标记的过程与 标记-清除算法一致
整理：把存活的对象依次排列，而把没标记的对象清除掉
好处：这样弥补了标记-清除算法带来的空间不连续的问题、也解决了复制算法带来的50%空间消耗的问题





············中间省去笔记 下次写



## JVM优化

逃逸分析：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
如果一个对象在方法中创建，而且并不会被其他方法所引用到，那么就是没发生逃逸。这个时候对象是分配在栈空间的（使用用标量替换），这样的话随着栈帧出栈的时候对象也可以被回收了，不需要垃圾收集，
（方法逃逸和线程逃逸就是看对象有没有在方法外 别的线程被引用）

锁消除：也叫同步省略。同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程，比如同步快的锁对象就在方法中创建的，那同步没有意义，这样子JIT会省略去这个同步代码

标量替换：标量（Scalar）是指一个无法再继续分解的数据，java中的基本数据类型就是标量，而对象则就是聚合量（Aggregate）。在JIT阶段，当经过逃逸分析后发现一个对象是不会被方法外部所访问的话，那么经过JIT优化，会把对象分解成若干个标量。比如有个Point类，里面有x和y两个int变量，那么在方法中创建这个对象并且使用x 和 y的时候，由于Point对象并没有逃逸出方法，所以被优化分解成了x和y两个int来使用

逃逸分析是JDK1.6才实现的，目前并不是特别成熟，它也有不足之处在于并不一定能确保处理逃逸分析消耗的性能一定低于原本的性能消耗，比如在极端的情况下，并没有任何对象发生逃逸。那么这个执行逃逸分析的时间就浪费了（也就是解释器的解释阶段）。


内存管理工具（JDK自带）：jps（查看进程）、jstat（查看内存情况和垃圾回收）、jinfo（查看和调整虚拟机参数）、jmap（查看和导出各种数据、比如存活对象、堆情况等）、jhat（通过jmap导出的堆对象信息文件，然后分析这个文件，分析过程特别消耗CPU资源和内存，所以一般是不直接在服务器运行，而是拿下来到其他机子查看）、jstack（查看各个线程的栈信息，排除死锁问题等，跟ANR的时候trace文件差不多）、jconsole（图形内存监控，可以看到当前堆的使用情况线形图（Eden、老年代等这些））




## 问题：什么是堆？栈和堆有什么区别？
堆就是一颗完全二叉树、有最大堆和最小堆，比如最大堆的话就是每个节点的值总是不小于子节点的值。
通常来说，堆是用数组来表示的一颗完全二叉树。

高度：n个节点的堆，高度是log n。根是第0层，第i层的结点数量就是2的i次方，那么反过来，第i个节点就是处在于log i层。

由于堆有log n层深，插入结点、删除普通元素和删除最小元素的平均时间代价和时间复杂度都是O(log n)

对于第i节点来说
left(i) = 2i+1
right(i) = left(i)+1 = 2i+2 ( 左节点和右节点总是相邻的)
parent(i) = (i - 1)/2
(java 里，优先级队列PriorityQueue就是堆，看一看。自己想的是：因为堆有最大最小能做调整，所以满足优先级)


## 堆空间是线程共享的区域，那么在创建对象的过程会有线程安全问题吗

涉及到线程安全问题，可能空间被A线程申请了还没来得及更新而B也在申请
所以解决方案是：如果加锁也可以解决问题，但是效率太低。
所以就在eden分区为每个线程分配独立的小空间（默认1%），这样每个线程就可以往自己的空间去分配
这个东西就叫做TLAB（Thread local allocation buffer）
（注意：网上说TLAB是线程私有的，需要理解为是线程私有分配的，但是其它线程都是可以访问的，只是其它线程没发在这里进行分配）
当TLAB没有空间时，
一种做法是分配到新的大的TLAB，
一种做法是分配到EDEN分区共享区域，不过这样的话就需要加锁来避免安全问题。

## 那些内存区域会产生溢出错误，哪些不会？
 
  除了程序计数器不会产生溢出之外，其它都会。
OutMemoryError
StackOverFlowError

## 问题：eden分区80%，Survivor区域只有10%，假如在挪到s1或s2时，s1或s2的内存空间存不下怎么办？
自己的回答：eden区分的对象一般都是刚创建的对象，很多对象的生命周期都特别短，每次都可以清除大部分的对象。
如果遇到大点的对象则直接放到老年代了。

## 对象在新生代什么时候才会到老年代？由什么东西决定？
有一种情况在eden区域中对象空间较大，不方便直接复制到survivor区，那么直接会挪到老年代来
第二种情况是对象在survivor两个区域中来回复制，当gc的次数达到一定的阈值后就会到老年代
这个gc的次数记录它是放在对象头里 也就是markword里，占了4个字节，最大是15.

## 什么情况下对象在栈上分配

栈上分配是JVM提供的一项优化技术。目的也就是为了减少GC的成本。
基本思想是，对于那些线程私有的对象，可以将它们打散分配在栈上，而不是在堆上。
这样以来，当方法执行结束后，栈上的对象可以自动被释放，不需要GC的介入。
（逃逸分析？大对象？）
经过逃逸分析，方法逃逸和线程逃逸，如果方法没有被别的线程持有、没有被方法外所持有，那么可以直接栈上分配
如果是大对象的话，栈上分配不下就只能去堆了
## 运行时常量池放在哪个内存区域
运行时常量池（Runtime Constant Pool）是方法区的一部分（jdk7 以后，常量池被放到了堆中 ），
用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，
直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；
运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量
（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符 “abc” 已经在常量池中，则返回池中的字符串地址，
否则，新建一个常量加入池中，并返回地址。）
而在jdk7之后就把运行时常量池方在堆中。
所以在jdk6，常量池溢出的异常是OutOfMemoryError：PermGen Space
而在jdk7之后，异常是：OutOfMemoryError：Java heap space
（拿一个String的intern()方法就可以模拟常量池溢出）

## JDK8之后，方法区用什么来取代？有什么区别？

jdk8之后，方法区也就是永久代被元数据区（mataSpace）所取代。
方法区在逻辑结构上也是属于堆里的一块内存，它也会触发GC的回收，主要针对的是常量池和类的卸载
但是类的卸载在实际场景很少，常量池又在1.7后移出了方法区。
那么在1.8之后用元数据区在本地物理内存区域来划分（默认不限大小，也可指定），就不需要再对方法区进行单独的内存管理，也不会有OOM。


## 新生代要分为三个区，为什么是8:1:1？
新生代三个区：每次触发minor GC，如果没有survivor分区 eden分区总是复制到老年代，这样搞多老年代容易触发full gc那不行。
所以需要有个中间区域来存放这些存活的对象，那么就需要一个survivor区域，而另外一个survivor区域是为了内存碎片化整理，两个区域可以相互复制，每次都清楚掉另外一个区域的碎片
新生代采用了复制策略：就是内存一分为二，每次gc时把存活对象复制到另外一个区域。对象分配到eden分区，eden分区又复制到s1和s2之间 复制来复制去。
而新生代大多数对象生命周期都是特别短的，没必要根据1:1的方式来切分内存，所以用了8:1:1来进行划分，为了避免空间上的浪费

## 新生代和老年代触发GC的时机，各自所采用的垃圾回收算法

当eden区域满了之后就会进行一次minor GC ，对于一些比较大的对象就直接挪到老年代，而其它存活的对象就放到survivor区。

比如一开始 eden区域gc后存活的对象方刀survivor区域from区域，
那么下次再发生minor gc时就把eden区域连同from区域存活的对象都复制到to区域，然后清空这两个的内存。
有部分对象可能会在survivor两个区域中来回复制多次，当survivor区域中的对象gc次数超过15（对象头markword里存放gc次数），那么就会把对象转入老年代。

minor gc会发生的比较频繁，毕竟每次分配对象都需要往eden里丢，但是因为区域较小，所以直接采用复制算法也很快，也避免了去处理内存碎片问题


如果老年代空间不足了触发GC是major GC，也就是Full GC。
因为发生一次full GC面向的内存会比较大，而且对象存活的周期相对较长，所以并不适合用复制算法。
老年代就采用了标记-整理算法，把存活的对象以此标记排列，把没标记的对象清除掉。这样能保证内存的连续性，也不会因为复制过程需要浪费额外的空间
major GC一般比minor GC要慢得多 


