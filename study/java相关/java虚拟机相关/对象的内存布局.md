## 对象的创建

指针碰撞和空闲列表：涉及到线程安全问题，可能空间被A线程申请了还没来得及更新而B也在申请
所以解决方案是：如果加锁也可以解决问题，但是效率太低。
设定本地线程分配缓冲，每个线程分配不同的区域。每个线程创建的对象内存都在不同的地方，避免了同时申请对象的时候使用了相同的空间
（个人理解：这就是为什么要每个线程独立一份内存空间？在eden分区中给每个线程分配独立的小部分空间）

## 内存分配的两种方式 
看堆内存是否规整，
指针碰撞：左边都是用过的内存，右边是没用的，中间用一个指针来作为分界点。分配时通过这个指针往右挪动需要的空间
空闲列表：如果堆内存不规整，那么就没办法用指针碰撞，就只能维护一个表来记录那些没用的内存区域。当分配完内存时就及时更新这个空闲列表

对象的结构：
Header（对象头 Mark Word）：自身运行时的数据，比如哈希值、GC分代年龄、类型指针、锁数据
实例数据、
Padding（对齐填充）


对象的访问定位：
使用句柄（开辟一个句柄池 通过查找句柄池定位到堆中的对象地址）
直接指针（hotSpot就是这样）


## 对象大小计算

在32位系统中，klass指针占4字节，markword是4字节，总共8字节
在64位系统的话，klass是8字节，markword是8字节，总共16字节
如果64位系统开启了指针压缩的话，那么klass变成4字节，总共就是12字节。

hotspot中内存管理要求对象大小必须是8的整数倍，所以才会有最后一个padding的部分，
如果对象头加上实体数据后不满足8的整数倍则通过padding来追加 padding alignment

## 为什么对象大小需要是8的整数倍

在计算机中的一种常见对齐方式，不仅仅是hotspot特殊的要求。
比如在计算机64位系统中，一次能读取8 bytes，那么8 bytes就是一个读写单元。
如果能确定对象一定是8bytes的整数倍，那么就能每次往8bytes去读取内存，就方便了计算机的寻址和编址



