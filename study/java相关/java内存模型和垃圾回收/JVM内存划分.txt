视频教程：https://www.bilibili.com/video/av29502877/?p=22
博客： 直接百度
https://blog.csdn.net/yhyr_ycy/article/details/52566105

JVM划分线程共享和线程独立的区域

线程共享的区域是方法区和java堆

独立的区域是虚拟机栈、本地方法栈、程序计数器


程序计数器：就是指向当前字节码执行到的指令地址（理解为代码的行号），思考：netive方法的时候程序计数器是undefine，为什么是underfine


虚拟机栈：每个方法执行的时候会创建一个栈帧（具体就是存放了局部变量表、操作数栈、动态链接、方法出口等），入栈后方法执行完毕出栈。当栈存放满了又还有栈帧入栈时，就会抛出StactOverFlowError的异常。。

局部变量表：内存空间是在编译期间就已经完成分配的，执行该方法的栈帧需要为这个局部变量表分配多少内存是固定的，运行期间不会改变大小，该内存空间是存放各种基本数据类型、引用对象（指针，注意不是对象内存）、返回值类型。

本地方法栈(hotspot不区分虚拟机栈和本地方法栈)：虚拟机栈是提供给java运行方法的服务的，而本地方法栈则是java运行natvie方法栈服务的

堆内存（共享）：存放对象实例的，垃圾收集器管理的主要区域。分为新生代和老生代、Eden分区

方法区（共享）：存储虚拟机加载的类信息（通过ClassLoader）、常量、静态变量。也就是说编译器编译后的代码数据。申请失败的时候则会抛出OutMermoryError


对象的创建：
指针碰撞和空闲列表：涉及到线程安全问题，可能空间被A线程申请了还没来得及更新而B也在申请
所以解决方案是：如果加锁也可以解决问题，但是效率太低。
设定本地线程分配缓冲，每个线程分配不同的区域。每个线程创建的对象内存都在不同的地方，避免了同时申请对象的时候使用了相同的空间
（个人理解：这就是为什么要每个线程独立一份内存空间？）

对象的结构：
Hearder（对象头 Mark Word）：自身运行时的数据，比如哈希值、GC分代年龄、类型指针
实例数据、
Padding（对齐填充）


对象的访问定位：
使用句柄（开辟一个句柄池 通过查找句柄池定位到堆中的对象地址）
直接指针（hotSpot就是这样）



垃圾回收：
判断对象是否存活的两个算法：
引用计数法：有引用就累加1，但是如果两个对象相互引用又没被其他对象所持有，则造成泄漏
缺点：泄漏
可达性分析法：设定一个GCRoot往下搜索引用链，判断结点是否可达，不可达则说明没有对象指向它，则是可回收对象
缺点：搜索性能问题、另外一个是线程停止的问题（Stop The World）：在执行分析期间，对象的引用关系不能发生变化，


标记-清除算法：
标记是采用可达性分析发（遍历Root）
清除：把标记了的对象清除掉
考虑的问题：效率问题、空间问题（清理后空间不连续、碎片很多，如果需要申请大内存空间又没有连续的大内存空间用）

复制算法：
把内存划分为两个空间 成为空闲空间和活动空间，各占50%。
对象的使用都放在了活动空间，当发生清理时，把存活的对象按照内存连续依次排列到空闲空间来（此时空闲空间就编程了活动空间），而把原来的活动空间的数据全部刷掉，变成了空闲空间。
这样解决了标记清除算法导致的清理空间后空间碎片太多不连续的问题。
但是带来的另外一个问题是很要命的，就是没了50%的空间
另外一个是极端的问题是假如存活的对象占100%，那么就需要把所有的对象都复制一遍，并且修改引用地址。这个时间开销是非常多的



标记-整理算法
标记的过程与 标记-清除算法一致
整理：把存活的对象依次排列，而把没标记的对象清除掉
好处：这样弥补了标记-清除算法带来的空间不连续的问题、也解决了复制算法带来的50%空间消耗的问题





············中间省去笔记 下次写





逃逸分析：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
如果一个对象在方法中创建，而且并不会被其他方法所引用到，那么就是没发生逃逸。这个时候对象是分配在栈空间的（使用用标量替换），这样的话随着栈帧出栈的时候对象也可以被回收了，不需要垃圾收集，


锁消除：也叫同步省略。同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程，比如同步快的锁对象就在方法中创建的，那同步没有意义，这样子JIT会省略去这个同步代码

标量替换：标量（Scalar）是指一个无法再继续分解的数据，java中的基本数据类型就是标量，而对象则就是聚合量（Aggregate）。在JIT阶段，当经过逃逸分析后发现一个对象是不会被方法外部所访问的话，那么经过JIT优化，会把对象分解成若干个标量。比如有个Point类，里面有x和y两个int变量，那么在方法中创建这个对象并且使用x 和 y的时候，由于Point对象并没有逃逸出方法，所以被优化分解成了x和y两个int来使用

逃逸分析是JDK1.6才实现的，目前并不是特别成熟，它也有不足之处在于并不一定能确保处理逃逸分析消耗的性能一定低于原本的性能消耗，比如在极端的情况下，并没有任何对象发生逃逸。那么这个执行逃逸分析的时间就浪费了（也就是解释器的解释阶段）。


内存管理工具（JDK自带）：jps（查看进程）、jstat（查看内存情况和垃圾回收）、jinfo（查看和调整虚拟机参数）、jmap（查看和导出各种数据、比如存活对象、堆情况等）、jhat（通过jmap导出的堆对象信息文件，然后分析这个文件，分析过程特别消耗CPU资源和内存，所以一般是不直接在服务器运行，而是拿下来到其他机子查看）、jstack（查看各个线程的栈信息，排除死锁问题等，跟ANR的时候trace文件差不多）、jconsole（图形内存监控，可以看到当前堆的使用情况线形图（Eden、老年代等这些））


