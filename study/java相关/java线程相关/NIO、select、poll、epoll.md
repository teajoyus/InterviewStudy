# BIO
正常来说IO，一个线程对应一个连接，
因为线程需要读取客户端的数据，而一直阻塞。
比如java里我们用Socket时，它的accept就是阻塞的，还有拿到客户端的输入流的读取流的时候也是阻塞的。
如果来了第二个连接的话就只能新建一个线程来做出响应。
主要涉及到线程的开销成本和复杂度就很高。

# NIO
后来java就有了个NIO中（NonBlocking IO）
提供了一种不阻塞的办法，也就是面向通道的。
它的accept或者read方法都可以不阻塞。
每次调用方法可以立即拿到结果。
这样就可以多个客户端连接到一个线程中来。
只是说这个过程就依旧还是要不断轮询是否有新的连接或者新的数据读取。（Bytebuffer）

# 多路复用
后面有了多路复用的模型。内核里面提供了一种多路复用器
内核会帮你保存这些fd（file drisrption 描述符），然后可以告诉你哪个fd是有新数据的，你就可以直接取这个fd
（这个就涉及到内核态和用户态的数据拷贝，系统调用->是CPU中断（中断向量表），不是直接调用）
系统会监听这些描述符，一旦有对应的IO产生就会通知给应用程序。
这样就不用应用程序自己每个来轮询了。

## select
实现方式：selector
它可以让这个阻塞
第一个提出了一个slector 选择器。
O(n)时间 -> 有IO事件发生只能遍历所有流看是哪个fd需要修改
当有的话就对fd标志位做处理，然后又把整个数组fd_set从内核空间拷贝到用户空间
所以缺点就是：
1、单个进程大小限制 （32为1024 64为2048）
2、是轮询扫描，时间复杂度O(n)
3、内核空间和用户空间复制数据 开销；

## poll
第二个是poll，改进的是selector每次拷贝的是数组，有大小限制。
而poll改成了链表的方式就没有这个大小的限制
复杂度还是O(n) 底层还是没变
poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。
（除非应用自己修改状态）
使用32位整数的 32位（bitmap 一个是1位）

## epoll
poll会把哪个流发生了怎样的I/O事件通知我们。
所以我们说epoll实际上是事件驱动（每个事件关联上fd）的
所以都是有针对性的对流进行操作，复杂度降到O(1)
mmap（只在create、ctl_add、wait是mmap实现的）
通过mmap在用户空间和内核空间共享一块内存
红黑树来存储socket
两种模式：一种是通知一次后就不会第二次了 所以数据要一次性读完。

java中的NIO在linux上是epoll的，比如在android系统上就是epoll


## mmap 
mmap是将一个文件映射到内存的方式。

mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。

面向流的设备不能进行mmap

 mmap() 通常是用在有物理介质的文件系统上的。
通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。




binder怎么利用mmap函数
mmkv也使用了mmap

## 内核空间
由于CPU某些指令比较危险，如果错用会导致系统崩溃，为了保护系统，操作系统将内存空间划分为了两部分

## 用户空间用传统IO读取文件
### 读取
1、进程发起一个读指令的系统调用
2、DMA(直接存储器，一个CPU的辅助器，不经过CPU控制)将文件数据拷贝到内核空间的缓冲区
3、CPU再把内核空间的缓冲器拷贝到用户空间的缓冲区来
### 写入
1、进程发起一个写函数的系统调用
2、CPU把用户空间的数据拷贝至内核空间的缓冲区
3、MDA再将内核空间的缓冲区数据写入到对应的IO设备中

整个过程就是用户空间与内核空间的数据拷贝由CPU完成，而内核空间与IO设备的拷贝则又DMA来操作


# binder
本质是内存的拷贝，binder驱动本身是一个运行在内核态的文件。
A进程通过把数据拷贝过binder，也就是发生了一次用户空间到内核态的copy，而binder会提前与另外一个进程通过mmap内存映射的方式，
让其它进程能直接通过操作内存的方式来映射拿到数据。
（用户空间的一块内存区域映射到内核空间。
映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；
反之内核空间对这段区域的修改也能直接反应到用户空间。）





