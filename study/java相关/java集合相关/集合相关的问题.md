HashMap实现原理
数据结构中有数组和链表来实现对数据的存储

HashMap和HashTable的区别
------------

HashMap不是线程安全的，并且可以有null值，而HashTable是线程安全的（获取和修改的时候需要先获得锁,它的get put方法都是带同步关键字的），也不允许有null值
HashMap是fail-fast迭代器，而而HashTable是enumerator迭代器 不支持（jdk1.8之后支持）
HashTable多了 contains(Object value) （跟迭代器有关吧）和elements()方法

fail-fast和fail-safe迭代器
fail-safe允许在遍历的过程中对容器中的数据进行修改，而fail-fast则不允许。
fail-safe:这种遍历基于容器的一个克隆。

常见的的使用fail-fast方式遍历的容器有HashMap和ArrayList等
使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList


在java 5中 提供了ConcurrentHashMap来，它是HashTable的替代，比HashTable的扩展性更好。（两者什么差别？）


Arraylist 与 LinkedList 异同
-------------------------
ArrayList 和 LinkedList 都是不同步的,Vector才是同步的
Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；


ArrayList中elementData为什么被transient修饰
------------------------------------
transient用来表示一个域不是该对象序行化的一部分

避免序列化浪费空间：List的元素数组是自动扩容的，直接序列化的时候会序列化整个扩容后的数组
所以写成transient的，然后重写了writeObject的时候用：
```
  for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }
```

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。
而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。
反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。


红黑树
---
红黑树（Red Black Tree） 是一种自平衡二叉查找树,典型的用途是实现关联数组。

先要理解二叉查找树，也就是左边的元素节点小于父节点，右边的结点大于父节点。查找的时间复杂度最坏情况是树的深度
缺陷：在插入的过程中很容易倾向于一边儿导致树的深度不断扩大，导致搜索成为了线性搜索

HashMap的长度为什么要是2的n次方
--------------------
HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；

取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作
（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。
个人理解：2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；
在计算碰撞的时候有关吧


自己再次滤清：
- 为什么取余操作时，除数是2的幂次方就等于是&(除数 -1) 

取余操作，从二进制角度来说。 

取余操作，跟&操作特别相像，因为被取余数大于除数的那部分1被&操作后都变成0了。
而这时候就剩下1右边这部分，原则上被&操作就相当于取这个被取余数的右边这部分，就是余数了。



- 根据要用哈希值来&上除数 -1，带代替取余。为什么初衷要取余

首先利用hash值来取余长度是可以均匀分布的。

因为并不知道hash值是多少，那么取余就只能相同概率的散落到各个位置，这样从概率来说相对均匀

而用&来代替取余是为了效率，因为hashMap在每次存取都需要去计算链表数组的位置。
用&操作会比取余操作效率更高，在操作大量数据的情况下得到体现。



- 重点问题：为什么长度是2的幂次方就能减少碰撞概率，能均匀分布？



因为如果长度是2的幂次方的话，在计算哈希碰撞也就是：hash&(length-1)的时候
如果length是2的幂次方就意味着二进制的时候，1后面全部是0， 比如16就是： 0001 0000
而length - 1的时候，二进制表示就是1后面的0全部变成了1， 比如16 -1 = 15，就是： 0000 1111

这个时候用哈希值再来&上这个一连串的1的时候，就会根据hash值对应的位&上1得到原先对应的位

举个例子，比如hash值是8， 那么二进制就是 0000 1000， 假设length =16，那么计算存储位置的时候就是：

```
  0000 1000
  
& 0000 1111
-----------
  0000 1000 
```

这样就相当于hash值被取余在length这个范围（也就是不会大于等于length）
同时，得出不同的余数就能均匀的对应到不同的存储位置


而如果不是2的幂次方，那么这里在&的时候就不会全部是1，就造成**如果除数的某位是0，那么hash值的对应位无论是1还是0都是0**，这样如果两个不同的hash值只有这一位不同，那么得出的结果也是相同的，就产生碰撞了。

所以length不是2的幂次方，那么这个等式就不等同于取余了，所以得到的余数就不是相同概率的，就不是均匀分布更可能产生碰撞



- 为什么长度不直接2的幂次方 - 1



什么是HashMap的负载因子
---------

- 负载因子的概念

就是在扩容的时候用到，表示当当前长度达到最大程度一定的阀值，就会进行扩容

HashMap默认的负载因子是0.75，默认容量是16。也就是当你在添加第13个数据的时候就会触发扩容，把内容扩容到了32（2的幂次方）

由此可见它的取值只能是(0,1]


- 负载因子作用（为什么要设定这个负载因子）

如果负载因子越大，那么当前容量能被填满的程度就越高，也就是能容纳更多的元素，这是它的好处。
但是带来的坏处是因为容纳的因子多了，触发碰撞的几率就会更大，更有概率会使得链表长度更大，就影响了索引的效率。
所以要在这两个之间权衡出一个居中点 尤为重要。

- 为什么负载因子默认是0.75

通过大量的实验，得出了0.75算是一个比较折中的数字


Set集合（不重复）
----------
HashSet 无序，不重复  基于 HashMap 实现的，底层采用 HashMap 来保存元素

LinkedHashSet通过 LinkedHashMap 来实现

TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)

