HashMap实现原理
数据结构中有数组和链表来实现对数据的存储

HashMap和HashTable的区别
------------

HashMap不是线程安全的，并且可以有null值，而HashTable是线程安全的（获取和修改的时候需要先获得锁,它的get put方法都是带同步关键字的），也不允许有null值
HashMap是fail-fast迭代器，而而HashTable是enumerator迭代器 不支持（jdk1.8之后支持）
HashTable多了 contains(Object value) （跟迭代器有关吧）和elements()方法

fail-fast和fail-safe迭代器
fail-safe允许在遍历的过程中对容器中的数据进行修改，而fail-fast则不允许。
fail-safe:这种遍历基于容器的一个克隆。

常见的的使用fail-fast方式遍历的容器有HashMap和ArrayList等
使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList


在java 5中 提供了ConcurrentHashMap来，它是HashTable的替代，比HashTable的扩展性更好。（两者什么差别？）


Arraylist 与 LinkedList 异同
-------------------------
ArrayList 和 LinkedList 都是不同步的,Vector才是同步的
Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；


ArrayList中elementData为什么被transient修饰
------------------------------------
transient用来表示一个域不是该对象序行化的一部分

避免序列化浪费空间：List的元素数组是自动扩容的，直接序列化的时候会序列化整个扩容后的数组
所以写成transient的，然后重写了writeObject的时候用：
```
  for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }
```

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。
而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。
反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。


红黑树
---
红黑树（Red Black Tree） 是一种自平衡二叉查找树,典型的用途是实现关联数组。

先要理解二叉查找树，也就是左边的元素节点小于父节点，右边的结点大于父节点。查找的时间复杂度最坏情况是树的深度
缺陷：在插入的过程中很容易倾向于一边儿导致树的深度不断扩大，导致搜索成为了线性搜索

HashMap的长度为什么要是2的n次方
--------------------
HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；

取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作
（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。
个人理解：2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；
在计算碰撞的时候有关吧

Set集合（不重复）
----------
HashSet 无序，不重复  基于 HashMap 实现的，底层采用 HashMap 来保存元素

LinkedHashSet通过 LinkedHashMap 来实现

TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)