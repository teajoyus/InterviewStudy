# 并发
## 死锁是什么意思？
死锁，我自己的话讲，就是多个线程在运行过程中相互竞争资源而产生的永久的阻塞
## 死锁产生的条件
看书中说4个条件，比如互斥条件啊、请求与保持、不剥夺条件、环路等待。
说白了就是说一个线程持有一个排它锁，然后一直持有着资源别人没发打断它，然后它自己也一直保持着
但是还想去请求另外一个资源，而另外一个资源又一样被其它线程保持着，而保持这个资源的线程又在等待你保持者的那个资源。
## 死锁的产生至少需要多少个线程/进程和多少个资源
两个线程和两个资源就够了。A线程持有a资源又在等待b资源，B线程持有b资源又在等待a资源

## 举了一个例子，A占有一个锁，写了个死循环，B一直等待这个锁，这种情况算不算死锁。
不算。这只能说是死循环。而且一般也有跳出死循环的条件。
B虽然因为A而一直阻塞，但是A没有因为B而阻塞，从某方面来说，A是一直在正常运行的。
（这里配合说下死锁产生的条件）

## 进程与线程的概念和区别
从书上的概念来说，线程是CPU调度的最小单元，而进程是资源分配的最小单元。

一开始发展的时候还没有线程的概念的，但是进程本身进行上下文切换的开销特别大、
而且应用内也可能需要做并发，同时处理多个任务。所以就衍生了更小执行单位的线程。一个进程可以有1个或者多个线程
不同的进程之间空间是相互独立的，而同一个进程里的多个线程是可以共享空间的。


## 一个进程有10个线程，有多少个栈？堆呢
在java里，栈有本地方法栈和虚拟机栈，这是线程所私有的，所以应该是1对1的
而堆是线程共享的。所以一个进程里就一个堆。然后多个线程来共享。

## 什么是线程安全
如果说多线程环境下操作一个对象，我们可以不用去考虑如何进行同步或者来修改和读取这个对象，就可以获取正确的效果。那么这个对象就是线程安全的。

## 锁相关，如何实现线程安全（synchronized/cas/lock）？
第一种是利用volatile关键字来修饰某个共享变量
第一种互斥同步：可以用synchronized关键字来进行同步、获取是用Lock，比如重入锁ReentrantLock[riˈɛntrənt]来实现同步。




## 为啥Java里面volatile修饰的i++还是线程不安全的
因为i++本身就不是原子操作，它分为了三步，第一步是获取i，第二步是获取i+1的值，然后第三步是把i+1的值写到i中。
这时候比如它要进入第三步之前，有其它线程刚好也执行第二步i+1
那么这时候第一个线程改变了i的值，但是第二个线程还是会把之前的值给写进去，
所以说volatile修饰的共享变量只能说它是为了可见性而做的，但是它不能保证原子性。


如果一个变量加了volatile关键字。这个变量是对所有线程共享的、可见的
每次读取都是最新写入的值并使其最新值在所有CPU里可见的。



## synchronized和Lock的区别？
synchronized本身是关键字层面的，它只能修饰方法 或者同步代码块。它是隐式获取锁和释放锁的。
但是Lock是一个接口类，提供了一对lock和unlock的方法。使用起来会比较灵活一点，
我们需要显示的在某个地方调用lock，然后需要在结束的地方手动调用unLock
Lock具备了synchronized一些没有的特性：
比如它可以尝试非阻塞的获取锁，那个tryLock
获取锁的过程也可以被中断、然后也有超时机制。


## Lock的实现原理？AQS？
Lock只是一个接口，它有几个实现类，比如重入锁ReentrantLock。
内部有一个东西叫做AQS，AbstractQueuedSynchronizer
这个AQS本身不做具体的同步操作，它只是提供一个框架。2
内部维护了一个volatile修饰的共享变量state，然后本身也是基于队列的。
它提供了那些setState、getstate、compareAndSetState这些方法让我们去修改这个共享变量
本质上就是基于这个state去做CAS操作，看看谁修改成功了就表示谁获取了资源。
一般来说我们就是需要去继承它，然后来完成自己同步操作的逻辑。
比如实现它的tryAcquire方法、tryRelease方法。或者是共享的tryAcquireShared。
比如ReentrantLock，它本身支持公平与非公平锁。
内部也是这两种锁去继承AQS，实现它的tryAcquire方法，然后利用CAS操作来修改这个state的值
公平与非公平就是差别在非公平的话就不会去判断这个队列了，公平的话就会插入到队列尾部。

## 解决线程安全的方式
1、利用volatile关键字；
2、使用synchronized关键字
3、使用Lock锁，就是各种Lock接口的实现类，比如ReentrantLock
4、使用ThreadLocal也算一种方式吧，就是每个线程自己一份拷贝

## 项目中哪里解决了线程安全
可能最常见的就是单例吧。
分享线上的一个bug。
就是在bugly上面出现了一个页面在销毁的时候，会偶发在Glide会报一个“you must no setTag()”什么什么的
配合Glide的源码就是说，每个图片任务都是一个Target，绑定到View里面的就是那个ViewTarget，
然后这个target里面就封装了我们的请求任务Request，然后这个Request是放在了View的tag里
当页面销毁的时候Glide触发释放机制，会遍历这些target然后拿Request，但是它拿不到就直接抛异常，正常来说是一定会有的
然后我们页面代码找了很多，基本都没有找到跟这个View的tag有明显关系的。
然后偏偏那个版本我刚好重构了我们的图片加载框架，所以问题就抛给我了。虽然大家也都在看这个问题，我们也复现不出来
然后临到发版的时候也找不出这个问题，所以我对应暂时的策略就是先确保线上的稳定。
把那几个异常的页面在onDestroy里try了一下。然后另外做了一个异常上报的机制
就是我想知道当发生异常的时候，这个View里面的tag是什么样子的。
最后在线上看错误发现了主动上报的这个错误，tag里打印出来的有很多种值，包括对应Glide用的那个tagId也可以打印出好多个值
然后也打印出来了一些奇怪的属性，我们没有赋值过的。
setTag打出堆栈 -> 发现是神策埋点赋值的 -> 发现是子线程下操作SparseArray
刚好那个版本升级了神策SDK -> 未下结论，对比了旧版本的神策，旧版本是在主线程。
后面神策自己又频繁了升级了几个版本，这个东西被恢复了。
然后在页面销毁的时候
神策埋点的


### 线程池相关，线程池的参数？作⽤？
ThreadPoolExecutor 线程池的参数有核心数量、存活时间、最大线程数量、队列容量、超时时间、是否允许核心线程超时、任务被拒绝的处理

### 怎么样合理分配线程池

这个看需求的出发点吧
比如任务的性质：是CPU密集型还是IO密集型或者不确定 混合型。
然后任务是否需要优先级、任务执行时间长短。
如果CPU密集型的话，就不适合配置太多线程，因为线程计算量太多，使用率太高，在某个时间段里其它线程拿到的CPU资源就少了（N+1）
如果IO密集型的话，可以多一点点，因为经常是处于阻塞状态，使用率会比较低（2N）
然后如果任务需要优先级的话，那么就得用优先级队列了。
任务执行时间也可以分配到不同的池里面，或者是优先级队列。


### synchronized锁类和锁对象有什么区别？
类锁本质上也是一个class对象，和对象锁没啥区别。
但是类锁和对象锁的意义就不太一样。
类锁的话就是针对于这个类的所有实例来说了，比如两个实例，A线程访问这个实例方法也获取了类锁，另外一个线程访问另外一个实例的方法就只能等着了。
如果对象锁的话就是针对这个对象来说了，不管这个类有多少个实例，看的是谁持有这个对象的锁。

### synchronized锁升级过程？
参考上面 无锁、偏向锁、轻量级锁、重量级锁
一开始 对象头markword里偏向锁直接写线程id
升级成轻量锁就是把markword赋值到栈帧中然后修改这个markword的指针指向这个对象锁，如果成功就是获得锁
重量级锁就是需要阻塞和唤醒了

### volatile了解吗？有什么⽤？底层如何实现？
volatile保证了在多处理器环境下共享数据的可见性
也就是说当一个线程修改了该共享变量，另外一个线程能读取到这个修改的值。
它的底层原理是
当修饰了volatile变量时，在进行写操作的时候，除了语句本身的指令，还会在后面加一个lock指令。
这个指令会触发当前的处理器将缓存行的数据写回到内存中，（缓存行就是CPU缓存的单元）
然后写回内存的操作会使得其它处理器缓存了该地址的数据无效。
这个其实还需要硬件来配合的，在CPU里有一个叫做缓存一致性的东西。
为了确保每个处理器的缓存是一致的，每个处理器都能嗅探在总线上传播的数据来检查自己的值是不是被修改了，
如果发现是被修改了，那么它就会把这个缓存行判断为无效状态，然后下次读取的时候检测到无效状态就重新去内存中拿。
（另外一个还是总线锁，会发消息给总线暂停所有的CPU，不过这个性能开销就有点大，不得已才用）

### 双重校验单例为什么要使⽤volatile，如果不加的话，哪⾥会出现问题？
只因为对象的创建过程也不是原子性的，它分为三步，就是分配空间、初始化对象、然后把栈中的指针指向堆中的对象空间来
而这个过程可能会发生指令重排序，就是可能栈中的指针已经指向堆了，但是实际上还没初始化好，
这时候另外一个线程来了，判断对象不为null就拿去用了，这就有问题了。
所以JDK1.5后面在volatile加入了关于重排序的禁止和优化（关于排序规则也不清楚了，什么happens-before规则，as-if-serial，说到底就是说要满足顺序的一致性）
这个volatile就能保证拿到的对象是已经初始化完毕的。

### java线程模型？可⻅性？原⼦性？有序性？
JMM这块比较抽象，本身是一种建立在内存上的一种抽象概念，感觉就是线程与内存之间的一个关系，屏蔽掉各种硬件和操作系统的内存差异。
在JMM里面是采用共享内存这种方式来达到通信的效果的（其它的信号量、管道、消息队列）
线程之间的通信是隐式进行的。
对于内存的访问，规定Java内存模型分为主内存，和工作内存；工作内存就是线程私有的部分，主内存是所有的线程所共享的
共享变量是存放于内存中，每个线程都有一个私有的本地内存区域（高速缓冲区），他们存储了共享变量的副本。
当两个线程进行通信，是线程A在本地内存区域把修改后的共享变量刷新到内存中，而这时候线程B是不知道的。
所以JMM就要来保证这个其它线程能再来内存中拿值去修改自己内存中的值,再从主内存中把共享变量刷新到自己的本地内存区域中。
它规范了线程之间何时看到其它线程写入的共享数据
其实我自己的理解，JMM的核心就是为了解决线程安全的问题，而线程安全的问题本质上就是对共享数据的操作，所以JMM规范了这一个操作流程

实现原子性:
1、一种是使用锁机制，它能保证一个共享变量在某个时刻只会存在一个线程在访问与修改。
2、一种是硬件层面支持的指令，也就是CAS。在执行CAS的指令时，只有内存地址的值与预期的值一致，才会写入，否则就什么都不做（一直自旋，占用CPU，适合低并发，因为不需要上下文切换）
（基本数据类型、引用类型的写操作都是原子性，long和double可能除外，32位机器分2次）

有序性：
我们的代码在经过编译器、虚拟机、甚至处理器都可能会产生重排序，因为重排序对内存访问操作有一定的优化
然后就有As-if-serial、happend-before规则，都是为了根据一些规则来禁止重排序，以免程序的执行与预期不一致。
As-if-serial就是说不管怎么重排序，程序执行的语义不应该被改变。
如果两个操作之间存在数据依赖关系那么就不应该对它们进行重排序，如果没有的话就可以。（编译器、runtime和处理器都必须遵守as-if-serial语义。）
它保证单线程的的执行结果不被改变。
对happned-before的话
像synchronized和volatile它们本身就可以保证有序性，因为它们会告知底层哪些指令应该禁止重排序，使得执行结果不会被打乱。
JMM保证了，假如A happens-before B的话，那么A的操作结果对B是可见的，而且一定是在B之前执行的。
它针对的是多线程同步的执行结果不被改变。

### 自己理解提问（CAS与volatile什么区别）
要说出volatile的原理和CAS的原理，而volatile本身针对的是线程的可见性，不保证原子性。而CAS是原子性的（它们两个没啥联系）


### 自己问（线程的工作内存与主内存同步时机）
如果没加volatile的话，就有几种情况：比如获取锁释放锁、线程切换、CPU有空闲
没回答好


### casABA问题？如何解决？
因为CAS在操作前会先比较当前的值是否和预期的旧值一致，但是它也只能检查是否一致，而没法断定这个过程是否曾被修改过然后又被修改了回来。
比如预期旧值是A，当前的值也是A，但是没发断定期间是不是其它线程改成了B随后再改成A. 这个就是ABA问题，
这个硬件层面也没发保证，所以在共享变量上增加对应的修改版本号，每次修改都追加一个版本。
（像Java也给我们提供了那个AtomicStampedReference、而AtomicInteger这些本身是CAS原子性但是没有版本号）

### sleep和wait的区别？
首先，sleep方法是Thread类才有的，而wait方法是Object的。
当线程调用了sleep方法后会暂停执行指定的时间，然后让出CPU，这时候所持有的锁不会释放。（进入阻塞状态）
但是调用了wait方法的话，就会释放锁，然后进入等待状态，只有别的线程针对这个锁对象调用notify后这个线程才能正常继续抢占锁。
而wait方法本身是针对于锁而言的，线程也只能在获取这个对象锁的前提下才能调用这个对象的wait方法。
而sleep只是Thread的一个静态方法，跟锁就没有什么关系。

### 处理器如何实现原子操作
一种是缓存锁。某个数据被缓存到CPU缓存行中时，处理器在将缓存行写回内存会导致其它处理器缓存了这个区域数据的缓存行无效。（缓存一致性，CPU能嗅探）

另外一种是总线锁。CPU对总线发出指令，总线上的其它CPU都会暂停。（性能开销大、效率低）
（并非都是缓存锁，假如被操作的数据不是被缓存在CPU内部，或者跨越多个缓存行没办法做标记。就是说可能有些数据不一定经过CPU内部的）

### 协程

协程是软件层面的一个概念，内部好像也是维护了一个线程池
kotlin：runBlocking、launch函数（GlobalScorp）、async和await

### 守护线程 demon thread
JVM会等待所有那些非守护线程的结束而退出，守护线程的例子就是GC线程，我们的线程都走完了 GC线程也跟着退出（它打finlly不一定会走）

### 多线程上下文切换
CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。这个过程会涉及到用户态和内核态的切换

### 怎么检测一个线程是否持有对象监视器
如果是当前线程的话，Thread类里有个holdsLock的方法，static方法，对应当前线程

## 怎么造成线程阻塞
sleep、wait、yield（使当前线程让出CPU，不过也不能保证它就被暂停了，因为也可能马上又抢到了）

## notify会造成锁释放吗
不会，notify的是唤醒那些wait的线程，同步代码块执行完才会释放锁，

## 为什么wait,nofity和nofityAll这些方法不放在Thread类当中
因为java提供的锁是对象这个层面的，放在Thread那就只能有拿到thread对象的前提下才能用到锁了，

## 怎么唤醒一个阻塞的线程
首先看这个线程因为什么原因被阻塞的，如果是调用wait的话，那就得用notify来唤醒。
如果是sleep的话，或者是调用了其它阻塞但是允许被中断的方法的话，那就可以用中断来唤醒它。
如果是IO阻塞的话就没办法了、因为IO涉及到了系统底层的

## FutureTask、Callable
FutureTask表示一个异步运算的任务、可以传入一个Callable的具体实现类。由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。

## 如果线程出现了异常怎么办
首先某个线程的异常并不会影响到其它线程，如果线程异常没catch的话，如果线程持有锁也会释放掉。

## 如何在两个线程间共享数据
应该有挺多的，比如wait与notify，或者是用Lock锁，拿到Condition用await和signal。
或者是阻塞队列 BlockingQueue
或者还有好多，就是说本质上是
(反过来 ThreadLocal、 安卓的话考虑Looper+Handler)

## 如何正确的使用wait()?使用if还是while?
一般是用while，因为可能被其它线程唤醒了，但是条件并不一定还能达到，所以得继续判断

## ThreadLocal
内部维护了一个线程一个ThreadLocalMap，
ThreadLocalMap的key就是这个ThreadLocal（弱引用）
泄露，因为ThreadLocal的value是强引用（本质上是一个变量不应该被弱引用），而key是弱引用（考虑到可以回收）
要是key被回收了，那么value找不到就泄露了，只有等线程终止、或者是下次get不到然后重置成null

## 如果你提交任务时，线程池队列已满，这时会发生什么
创建线程池的有时候有一个拒绝策略，默认是丢弃任务抛出异常（另外还有丢任务不抛异常、丢弃队列前面的、直接处理）

## 悲观锁&乐观锁
悲观锁：synchronized 每次都认为有其它线程要来抢占资源，所以要先拿到锁锁住再来
乐观锁：CAS实现的锁，每次去拿数据都认为别人不会修改它，然后写数据的时候就再检查下有没有被修改过，被修改了就一直继续尝试

## CyclicBarrier和CountDownLatch区别
CountDownLatch 线程await之后就一直等计时器到0后才能继续执行下去。（等待所有线程）
而CyclicBarrier是线程走到某个屏障就会阻塞住，直到所有线程到达后再打开屏障。（合并所有线程结果）

## 多线程中有哪些良好的实践
线程命名、同步范围越小越好、优先用volatile、考虑线程池、优先使用并发容器而不是同步容器

##volatile可以用于数组吗
可以用，但是本身它是指向数组的引用，这个一般也不可能变。如果是修改数组中的元素，对于volatile这个变量来说引用也没发生变化
