# 并发
## 死锁是什么意思？
死锁，我自己的话讲，就是多个线程在运行过程中相互竞争资源而产生的永久的阻塞
## 死锁产生的条件
看书中说4个条件，比如互斥条件啊、请求与保持、不剥夺条件、环路等待。
说白了就是说一个线程持有一个排它锁，然后一直持有着资源别人没发打断它，然后它自己也一直保持着
但是还想去请求另外一个资源，而另外一个资源又一样被其它线程保持着，而保持这个资源的线程又在等待你保持者的那个资源。
## 死锁的产生至少需要多少个线程/进程和多少个资源
两个线程和两个资源就够了。A线程持有a资源又在等待b资源，B线程持有b资源又在等待a资源

## 举了一个例子，A占有一个锁，写了个死循环，B一直等待这个锁，这种情况算不算死锁。
不算。这只能说是死循环。而且一般也有跳出死循环的条件。
B虽然因为A而一直阻塞，但是A没有因为B而阻塞，从某方面来说，A是一直在正常运行的。
（这里配合说下死锁产生的条件）

## 进程与线程的概念和区别
从书上的概念来说，线程是CPU调度的最小单元，而进程是资源分配的最小单元。

一开始发展的时候还没有线程的概念的，但是进程本身进行上下文切换的开销特别大、
而且应用内也可能需要做并发，同时处理多个任务。所以就衍生了更小执行单位的线程。一个进程可以有1个或者多个线程
不同的进程之间空间是相互独立的，而同一个进程里的多个线程是可以共享空间的。


## 一个进程有10个线程，有多少个栈？堆呢
在java里，栈有本地方法栈和虚拟机栈，这是线程所私有的，所以应该是1对1的
而堆是线程共享的。所以一个进程里就一个堆。然后多个线程来共享。

## 什么是线程安全
如果说多线程环境下操作一个对象，我们可以不用去考虑如何进行同步或者来修改和读取这个对象，就可以获取正确的效果。那么这个对象就是线程安全的。

## 锁相关，如何实现线程安全（synchronized/cas/lock）？
第一种是利用volatile关键字来修饰某个共享变量
第一种互斥同步：可以用synchronized关键字来进行同步、获取是用Lock，比如重入锁ReentrantLock[riˈɛntrənt]来实现同步。




## 为啥Java里面volatile修饰的i++还是线程不安全的
因为i++本身就不是原子操作，它分为了三步，第一步是获取i，第二步是获取i+1的值，然后第三步是把i+1的值写到i中。
这时候比如它要进入第三步之前，有其它线程刚好也执行第二步i+1
那么这时候第一个线程改变了i的值，但是第二个线程还是会把之前的值给写进去，
所以说volatile修饰的共享变量只能说它是为了可见性而做的，但是它不能保证原子性。


如果一个变量加了volatile关键字。这个变量是对所有线程共享的、可见的
每次读取都是最新写入的值并使其最新值在所有CPU里可见的。



## synchronized和Lock的区别？
synchronized本身是关键字层面的，它只能修饰方法 或者同步代码块。它是隐式获取锁和释放锁的。
但是Lock是一个接口类，提供了一对lock和unlock的方法。使用起来会比较灵活一点，
我们需要显示的在某个地方调用lock，然后需要在结束的地方手动调用unLock
Lock具备了synchronized一些没有的特性：
比如它可以尝试非阻塞的获取锁，那个tryLock
获取锁的过程也可以被中断、然后也有超时机制。


## Lock的实现原理？AQS？
Lock只是一个接口，它有几个实现类，比如重入锁ReentrantLock。
内部有一个东西叫做AQS，AbstractQueuedSynchronizer
这个AQS本身不做具体的同步操作，它只是提供一个框架。2
内部维护了一个volatile修饰的共享变量state，然后本身也是基于队列的。
它提供了那些setState、getstate、compareAndSetState这些方法让我们去修改这个共享变量
本质上就是基于这个state去做CAS操作，看看谁修改成功了就表示谁获取了资源。
一般来说我们就是需要去继承它，然后来完成自己同步操作的逻辑。
比如实现它的tryAcquire方法、tryRelease方法。或者是共享的tryAcquireShared。
比如ReentrantLock，它本身支持公平与非公平锁。
内部也是这两种锁去继承AQS，实现它的tryAcquire方法，然后利用CAS操作来修改这个state的值
公平与非公平就是差别在非公平的话就不会去判断这个队列了，公平的话就会插入到队列尾部。

## 解决线程安全的方式
1、利用volatile关键字；
2、使用synchronized关键字
3、使用Lock锁，就是各种Lock接口的实现类，比如ReentrantLock
4、使用ThreadLocal也算一种方式吧，就是每个线程自己一份拷贝

## 项目中哪里解决了线程安全
可能最常见的就是单例吧。
分享线上的一个bug。
就是在bugly上面出现了一个页面在销毁的时候，会偶发在Glide会报一个“you must no setTag()”什么什么的
配合Glide的源码就是说，每个图片任务都是一个Target，绑定到View里面的就是那个ViewTarget，
然后这个target里面就封装了我们的请求任务Request，然后这个Request是放在了View的tag里
当页面销毁的时候Glide触发释放机制，会遍历这些target然后拿Request，但是它拿不到就直接抛异常，正常来说是一定会有的
然后我们页面代码找了很多，基本都没有找到跟这个View的tag有明显关系的。
然后偏偏那个版本我刚好重构了我们的图片加载框架，所以问题就抛给我了。虽然大家也都在看这个问题，我们也复现不出来
然后临到发版的时候也找不出这个问题，所以我对应暂时的策略就是先确保线上的稳定。
把那几个异常的页面在onDestroy里try了一下。然后另外做了一个异常上报的机制
就是我想知道当发生异常的时候，这个View里面的tag是什么样子的。
最后在线上看错误发现了主动上报的这个错误，tag里打印出来的有很多种值，包括对应Glide用的那个tagId也可以打印出好多个值
然后也打印出来了一些奇怪的属性，我们没有赋值过的。
setTag打出堆栈 -> 发现是神策埋点赋值的 -> 发现是子线程下操作SparseArray
刚好那个版本升级了神策SDK -> 未下结论，对比了旧版本的神策，旧版本是在主线程。
后面神策自己又频繁了升级了几个版本，这个东西被恢复了。
然后在页面销毁的时候
神策埋点的


### 线程池相关，线程池的参数？作⽤？
ThreadPoolExecutor 线程池的参数有核心数量、存活时间、最大线程数量、队列容量、超时时间、是否允许核心线程超时、任务被拒绝的处理

### 怎么样合理分配线程池

这个看需求的出发点吧
比如任务的性质：是CPU密集型还是IO密集型或者不确定 混合型。
然后任务是否需要优先级、任务执行时间长短。
如果CPU密集型的话，就不适合配置太多线程，因为线程计算量太多，使用率太高，在某个时间段里其它线程拿到的CPU资源就少了（N+1）
如果IO密集型的话，可以多一点点，因为经常是处于阻塞状态，使用率会比较低（2N）
然后如果任务需要优先级的话，那么就得用优先级队列了。
任务执行时间也可以分配到不同的池里面，或者是优先级队列。


### synchronized锁类和锁对象有什么区别？
类锁本质上也是一个class对象，和对象锁没啥区别。
但是类锁和对象锁的意义就不太一样。
类锁的话就是针对于这个类的所有实例来说了，比如两个实例，A线程访问这个实例方法也获取了类锁，另外一个线程访问另外一个实例的方法就只能等着了。
如果对象锁的话就是针对这个对象来说了，不管这个类有多少个实例，看的是谁持有这个对象的锁。

### synchronized锁升级过程？
参考上面 无锁、偏向锁、轻量级锁、重量级锁
一开始 对象头markword里偏向锁直接写线程id
升级成轻量锁就是把markword赋值到栈帧中然后修改这个markword的指针指向这个对象锁，如果成功就是获得锁
重量级锁就是需要阻塞和唤醒了

### volatile了解吗？有什么⽤？底层如何实现？
volatile保证了在多处理器环境下共享数据的可见性
也就是说当一个线程修改了该共享变量，另外一个线程能读取到这个修改的值。
它的底层原理是
当修饰了volatile变量时，在进行写操作的时候，除了语句本身的指令，还会在后面加一个lock指令。
这个指令会触发当前的处理器将缓存行的数据写回到内存中，（缓存行就是CPU缓存的单元）
然后写回内存的操作会使得其它处理器缓存了该地址的数据无效。
这个其实还需要硬件来配合的，在CPU里有一个叫做缓存一致性的东西。
为了确保每个处理器的缓存是一致的，每个处理器都能嗅探在总线上传播的数据来检查自己的值是不是被修改了，
如果发现是被修改了，那么它就会把这个缓存行判断为无效状态，然后下次读取的时候检测到无效状态就重新去内存中拿。
（另外一个还是总线锁，会发消息给总线暂停所有的CPU，不过这个性能开销就有点大，不得已才用）

### 双重校验单例为什么要使⽤volatile，如果不加的话，哪⾥会出现问题？
只因为对象的创建过程也不是原子性的，它分为三步，就是分配空间、初始化对象、然后把栈中的指针指向堆中的对象空间来
而这个过程可能会发生指令重排序，就是可能栈中的指针已经指向堆了，但是实际上还没初始化好，
这时候另外一个线程来了，判断对象不为null就拿去用了，这就有问题了。
所以JDK1.5后面在volatile加入了关于重排序的禁止和优化（关于排序规则也不清楚了，什么happens-before规则，as-if-serial，说到底就是说要满足顺序的一致性）
这个volatile就能保证拿到的对象是已经初始化完毕的。

### java线程模型？可⻅性？原⼦性？有序性？
JMM这块比较抽象，本身是一种建立在内存上的一种抽象概念，感觉就是线程与内存之间的一个关系。
在JMM里面是采用共享内存这种方式来达到通信的效果的（其它的信号量、管道、消息队列）
线程之间的通信是隐式进行的。
共享变量是存放于内存中，每个线程都有一个私有的本地内存区域（高速缓冲区），他们存储了共享变量的副本。
当两个线程进行通信，是线程A在本地内存区域把修改后的共享变量刷新到内存中，而这时候线程B是不知道的。
所以JMM就要来保证这个其它线程能再来内存中拿值去修改自己内存中的值,再从主内存中把共享变量刷新到自己的本地内存区域中。



### 自己问（线程的工作内存与主内存同步时机）
如果没加volatile的话，就有几种情况：比如获取锁释放锁、线程切换、CPU有空闲
没回答好


casABA问题？如何解决？
sleep和wait的区别？