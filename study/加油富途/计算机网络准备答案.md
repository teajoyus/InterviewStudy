# 计算机网络 
## 七层网络模型
- 应用层 HTTP HTTPS DNS TFP
- 表示层 数据的表示，比如图片
- 会话层 对应主机进程，建立会话
- 传输层
- 网络层
- 链路层
- 物理层

## TCP/IP四层网络模型
- 应用层 HTTP HTTPS DNS TFP
- 传输层 TCP UDP TSL
- 网络层 IP ICMP UGMP
- 链路层 RAP ARAP

## tcp&udp
### tcp和 udp的区别
对TCP来说：TCP是面向连接的、可靠的传输协议。双方在建立通信之前，必须通过三次握手来确保连接的建立，
而在传输过程为了数据的完整性、可靠性，TCP还会提供超时重发、确认、校验、流量控制来做到数据传输的可靠保证。
而UDP的话就不提供这一系列的可靠性保证了，它只是把数据发送出去。并不需要提前建立连接，在传输过程也不关心是否丢包。
### Tcp和Udp有何优缺点？    
UDP的话会比较简单。因为它不需要建立建立连接，也不需要进行可靠性保证，所以传输效率高。
另一方面它的数据冗余会比较小，因为它不需要那么多控制字段，头部会比较小。
但是最大的缺点就是没法保证数据可靠传输了。

TCP的话，那就是跟UDP反着来的，既然它的最大优点就是保障了数据的可靠传输，使得上层应用可以不关心数据校验是否正确。
但是为了保证可靠传输，而做出的超时重发、确认、数据校验、流量控制等这些都影响了传输的效率。
而且需要加入更多的控制字段来判断报文的顺序啊、完整性校验啊，相对来说数据冗余也就多了，也是不利于传输效率的。

安全方面：
另外一个方面的话，TCP也挺不安全的，容易被攻击。攻击方的客户端只发送第一次握手给服务器，然后对服务器发回来的SYN+ACK什么也不做，直接忽略掉，
不发送ACK给服务器确认；这样就可以占据着服务器的半连接队列的资源，导致正常的客户端连接无法连接上服务器。
UDP可能相比会好一些，因为它不用建立连接，报文里也没有什么控制字段和序列号之类的，中间人比较难从UDP中分析出数据

### 为什么三次握手需要三次确认
主要是客户端和服务器之间两者都要确保彼此的连接和接收能力是否正常。
因为第一次握手，客户端给服务器发送SYN同步字段，服务器这时候就能确定有客户端要连接进来。
这时候服务器给客户端发送SYN+ACK字段表名自己确认收到你的连接了，但是我还是需要再试探客户端是否能正常接收数据。
最后一次客户端收到服务器了表面服务器的接收和响应都没问题，那么自己再发出ACK字段给服务器，服务器就认为客户端也是接收正常的了
（考虑一种情况 客户端发出后就关了）

### TCP和UDP的应用场景
（如果没回答过优缺点，可以先回答下再来引入）
UDP就对一些实时性要求比较高的应用来说就比较适合了，比如语音对话、视频会议啊、或者是游戏啊。这种都对实时性要求比较高
TCP的话就适用于那些对数据完整性有要求的场合了，比如收发一个文档，如果不能确保完整性，那就没意义了。


### UDP怎么保证可靠传输
UDP在传输层没办法保证可靠性，只能由上层自己来做校验了。可靠过程也可以模拟TCP的过程，比如进行包校验、定义序号确认之类的。

### TCP UDP包大小限制
UDP包本身理论上的话好像是2的16次方不到，大概就是64K。但是实际上不会这么弄。
因为如果包太大的话。在网络层，也就是IP层就需要采用分段的形式来拆分数据包了。
然后对方接收后又进行包重组，而UDP的不可靠性可能导致重组失败而数据包被丢弃。

所以一般就不要超出MTU比较好。
从链路层角度来说，以太网的数据帧长度一般是1500，成为MTU。而有些路由器 网络可能设置更小的值。比如取1500
而在网络层来说IP报文头部占有20字节，那么数据部分就不超过1500-20 = 1480
再往上一层传输层来说，UDP头部是8字节，那么数据部分就不超过1480 - 8 = 1472字节了。
所以最好就不要超过这个数，或者甚至会取更低的那个值，500多的那个。

而对于TCP来说，它就不一定是一个固定值，而是通过双方在建立TCP过程中协商的。
在建立TCP连接时，双方都有提供自己的MSS，然后取两者中较小的
MTU是数据链路层的概念。
如果默认的话就是由MTU来代替，而TCP包的头部是20字节，IP层也要20字节，所以长度就是1500-20-20 = 1460字节

### 如果用udp来做微信收发消息，怎么保证对方收到的消息是准确的
与《UDP怎么保证可靠传输》的回答类似把

### TCP是哪一层，IP是哪一层，哪一层高哪一层低
TCP是传输层、IP是网络层。从高到底：应用层->传输层->网络层->链路层

### 传输层还有什么协议？网络层还有什么协议？ICMP干嘛的
还有一个TLS协议，SSL这个。就是现在HTTPS在用的，安全性的可靠协议。
网络层除了IP之外，还有ICMP IGMP这些。
ICMP主要是作用于传递一些控制消息。比如网络连通性测试、主机可不可达、路由是否可用这些（另外ping命令也是用ICMP来，ICMP攻击）
链路层就是ARP ARAP。

### TCP如何保证可靠性
有很多种。首先从数据的完整性的角度来说：
1、通过校验和来确定数据是否正确（反码相加）
2、确认应答机制。每个TCP报文都有对应的序列号，接收方收到后会给发送方发送一个ACK（下一个开始的序列号）确认收到，发送方收到确认后就继续发送下一个（有个连续ARQ协议，分组，一组一组，累计确认）。
（1、停等协议：一个发等一个收；2、GoBackN，连续发送N个，没收到确认就继续重发n个，3、选择重传：接收方给一个否认帧的起点）
3、超时重传，如果说发送方等太久了还没收到接收方的确认，那么就会重新传一次。（发送出去后会启动一个定时器，不固定）
4、接收方这时候也就可能收到多次发送方的报文，所以自己也会根据序列号进行去重处理。
从传输流量的角度来说：
双方都必须按照一定的速率去传输，不然比如接收方的缓冲区满了，但是发送方还一直在发，这就不行了。
所以TCP就要保证发送方能根据接收方的接收能力来调整自己的速率。
在头部中就有一个窗口大小的字段来表示传输的大小。然后TCP就会根据双方的实际来调整这个窗口大小
（滑动窗口）
从网络的角度来说，因为网络是不可靠的，也是不稳定的。时好时坏。
所以TCP也引入了一种慢启动的机制，先试探性的发出来一点点，等摸清网络状况后再调整到最佳大小
还有什么快重传、快恢复的

### TCP和UDP哪一个吞吐量大
自己乱回答：网络好的情况下 UDP吞吐量大一点吧。但是实际上作用的效果也是不同的

### TCP的报文保证按序到达吗？为什么？如果报文不是按序到达的，那怎么交付给应用层
TCP为了确保数据完整性，对每个报文都会校验报文的完整性，然后再给发送方发送一次ACK确认，然后发送方收到确认后才会继续发下一个
如果没收到的话就会触发超时重传机制，而接收方也可能会多次收到同样的报文，所以接收方也会进行去重处理。
所以这个过程发送方都在确认接受下一个报文，而发送方也是在等接收方确认完再继续下一个报文


### 手撕TCP三次握手四次挥手过程
三次握手：
第一次：客户端发送syn字段（当然还有其他比如seq，此时变成SYN_SEND状态）
第二次：服务端接收到syn字段后，对客户端发送SYN+ACK（也还有seq，而ack是客户端的seq+1）
第三次：客户端变成连接建立状态，发送ACK给服务器，服务器接收到ACK后也变成建立状态（ack是服务器的seq+1）
（插曲：ack如果一直没收到会继续再发，超出一定次数就关闭连接）
四次挥手：
第一次：客户端发送FIN报文（表明自己已经没有任何数据要提交的了）
第二次：服务器发送ACK给客户端（表示我知道了）
第三次：服务器发送FIN报文给客户端（表名自己没有数据要发送了）
第四次：客户端发送ACK，并且进入TIME_WAIT状态。

### 为什么三次握手而挥手时需要四次
因为在第二次握手的时候，服务端可以一起把ACK+SYN字段同时发给客户端
但是在挥手的时候，客户端发送FIN报文。服务端只能先发ACK字段，因为它不一定也能及时发出FIN报文（可能还有数据还没发送完毕）
所以ACK和FIN报文就要分两次发。

### DNS用的是UDP还是TCP（udp适用于小包，无上下文的情况，好处是开销小）
之前也小有了解过，大概是说DNS首先会用UDP。正常来说一个UDP的包就可以了。
但是如果包太大的话，超过512字节，那么服务器就会告知客户端改用TCP。
然后客户端就重新发起TCP请求。

### 连接过程都有什么状态（应该不考）
LISTEN、CLOSED、SYN_SENT、SYN_RCVD、ESTABLISHED、FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT

### 对头阻塞
不问就不要说。
tcp第一个分片丢失了，然后后面的都一直在等它。比如一次TCP里多次http请求 后面的都在等它



## HTTP&HTTPS

### HTTP各个版本差异性
最早就是HTTP1.0，那时候的网络请求和网页这些都还比较简单。
后来更新了HTTP1.1,加入了：
1、断点续传，在header多了个range表示数据范围，（正常的响应码是206.没问就不说）
2、在header里多了个HOST，早起的时候一般一台计算机对应一个IP,但是后面虚拟机技术的发展就可能有多台了，所以加多个HOST字段来表示域名主机
3、长连接。建立起一次TCP连接后中间可以有多次HTTP请求和响应。（串行）
HTTP2.0：
1、多路复用：同一个域名访问多个文件的请求也可以复用一个tcp连接，且多个请求可以被并行处理。
（http2.0引入了一种二进制流的概念，每个流帧都有自己的id，所以可以参和在一起，后面进行重组就可以利用这些id）
头部压缩（大概就是客户端和服务器之间都会维护一个header表，然后双方都可以告知对方去更新这个表，然后头部就可以利用这些表做一个映射关系）
服务器推送。服务器能主动推送那些它认为客户端应该需要的内容（这个我感觉适用于web端吧，比如请求一个网页，客户端往往也需要再请求里面的js css文件之类的）
http3.0
用UDP协议的，然后自定义TCP的那些滑动窗口、流量控制的那些协议

### http格式？常⽤的请求头有哪些？
http请求格式：
第一个是请求行，请求行里标明了请求的类型GET或者POST、请求的资源（URL后缀）、协议版本
第二部分是请求头，请求头里就有host、user-agent（浏览器标识）、cookie、accept（传输文件类型）、accept-encoding（传输文件编码）、connection：keep-alive
第三部分是空行（用来区分头部和请求数据）
第四部分是请求体 请求数据。
http响应格式：
第一部分是状态行，由版本号、状态码、状态消息组成（比如http/1.1 200 OK）
第二部分是响应头，比如：
content-type
cookie
Transfer-Encoding（chunked 分块传输，因为不一定能计算大文件的content-length 或者不方便计算）
cache-control （请求头响应头都有，但它们取值不痛、请求头的话有缓存时间、no-cache、no-store标志之类的，响应头的话也差不多）
Last-Modified（客户端第二次会传if-motify-since、If-none-Match询问是否修改过，如果服务器没修改过则返回304）
（首次服务器如果支持缓存、那么就发送Last-Modified和ETag，客户端下次根据date和cache-controll判断是否过期，如果过期会在会在请求中携带If-Modified-Since和If-None-Match两个（取值分别是Last-Modified和ETag））
如果客户端不需要下载，则服务器返回304）
E-Tag 资源的唯一标识
第三部分是空行
第四部分是响应体

响应头：
content-length（报文长度）
content-encoding、content-type、expires

### http的状态码？分别有什么含义？
1xx：消息已收到，继续在处理
2xx：成功：表示请求的资源成功接收和处理，比如正常的200、断点续传的206
3xx：重定向
4xx：客户端有错误（一般我们碰见更多的是客户端请求的东西并不存在，比如404，比如ip写错了，或者url写错了）
5xx：服务器错误（服务器未能处理这次请求）
### get和post的区别？
1、get的请求数据是放在URL后缀的，post就不是。所以相比之下get请求更容易暴露出数据
2、get请求大小长度有限制，好像是1kb还是2kb了。浏览器可能对这个url会有长度限制。
3、get请求只能url编码、post请求就可以有多种编码
3、GET请求是把header和data一起发的，而POST是先发送header得到100响应后再发送data得到200的响应
  （不过这个跟浏览器或者工具关系更大，不是post本身的必要行为）  
4、我们项目的话有一些是get有一些是post，一般来说都是遵守客户端拿数据的话就用get，客户端有数据要提交修改的一般是post。
虽然说现在其实好多项目get和post都是乱用，但如果讲究的话，这里面也有一个幂等性的概念。
get请求都是幂等的，也就是说get请求并不会改变服务器资源的状态（尽管每次get请求数据不同）
但是POST就不是幂等的，它应该是作用在于创建资源数据上，比如两次POST应该是能创建两次资源。
相对的还有DELETE 、PUT。DELETE应该就是幂等的，两次DELETE应该只会删除同一个资源数据。
而PUT跟POST差不多，但是它是幂等的。就是PUT本身可以创建资源数据，但是也可以是更新数据（两次同样的PUT请求，第二次一般来说就是更新）

## http的优缺点
优点：简单灵活易拓展。
对我们应用来说 只要遵循对应的头部规则，然后数据都是文本格式。
易拓展是比如它的状态码、头部都可以作为未来拓展的东西
而且它是无状态的、明文方便我们调试
缺点：明文传输不安全

## https的握⼿过程？公钥存放在哪⾥？加密算法有哪些？为什么握⼿是⾮对称，传输是对称加密？

1、客户端发送一个 Client Hello报文开始SSL通信，报文中包含了加密组件（加密算法、长度等）
然后重点：客户端会附加一个随机数
2、服务端会以Server Hello作为应答，和客户端一样报文也包含了这些加密组件（不同的是服务器是在接收到客户端的加密组件后筛选出来的）
然后重点：服务器也会附加一个随机数
3、之后服务器再发送Certificate报文，该报文就包含了服务器的数字证书（公钥就在里面）
4、服务器再发送一个Server Hello done告知客户端，最初的SSL第一次协商阶段结束
（客户端hello、服务端hello、然后证书、然后hello done）

5、客户端对服务器发来的数字证书进行验证，如果验证成功就取出对应的公钥。（用CA公钥来解密这个数字证书的摘要部分，确认信息是否匹配）
6、客户端以**Client Key Exchange报文**回应，其中包含有一个随机密码串（Pre-master secret）。该报文利用服务器证书里取出来的公钥进行加密
（这时候客户端会以这个随机密码串结合前面两个随机值来生成一个对称加密的密钥）
7、客户端继续发送Client Cipher Exchange报文，用于告知服务端，客户端已经切换到之前协商好的加密套件了
8、客户端继续发送finished报文，该报文包含了全部报文的整体校验值，用于给服务端校验完整性
9、服务器收到后，用私钥来进行解密，取出客户端的那个随机密码串，然后服务器也发送Server Cipher Exchange报文
（这时候服务端也以同样的方式，用三个随机值来生成一个对称加密的密钥。这个密钥就是后面用来传输数据时用对称加密算法用的
只有数据完整性了对于双方来说才是可靠的）
10、服务器同样发送finished报文，也包含了整体校验值，用户给客户端校验
11、finished报文内容交换完毕后，SSL连接就算建立完成了，由此就可以开始应用层协议通信了
#### 为什么后面都要发送finished报文
要验证双方的身份，如果数据是客户端用服务器的公钥加密的，那服务器用私钥解密出来的应该是一样的
#### 为什么会产生三个随机数
对于客户端来说，在生成了这个随机密码串后，会结合前面两个随机数来推导出一个master secret
再用master secret推导出一个hash secret和一个session secret。
服务端也是一样这么推导，所以正常情况下他们推导出的值是相同的。
在双方进行对称加密的通信时，用hash secret对报文生成一个摘要，再利用session secret来进行加密
接收方通过session secret解密后，也用hash secret对报文进行一次计算，来匹配摘要验证数据是否被篡改

#### 为什么需要三个随机数，只用一个不行吗
这种会比较靠谱一点，因为计算机中的随机数本质上都是伪随机数，只用一个的话可能很容易被推导。
而用一个客户端的加上一个服务端的，就可以当做真正意义上的随机数了。

**另外一个如果建立通信时受到扰乱，比如被恶意重复发送报文，那么也可以通过这个随机数来区分干扰**

#### 如果中间人拦截了服务器的证书，并且对证书做了篡改会怎么样？

如果是改证书的内容的话，因为数字签名的存在，客户端可以区分出来。
如果是换掉了数字签名的话，因为黑客自己也不知道CA机构的密钥，所以客户端用CA公钥解密不出来正确的信息
如果说黑客也去同个CA申请了证书，客户端就可以正常解密出来，但是由于绑定的域名等信息不对称，客户端也会产生警告
#### 抓包工具 charies、Fildder为什么还能抓到https的包
这个前提也是得客户端安装信任抓包工具的证书啊。
抓包工具会把服务端的证书拦截下来，用自己的证书发给客户端，由于客户端已经信任改抓包工具的证书所以验证通过。
然后客户端在生成随机密码串的时候也是用抓包工具的公钥来加密的，而双方的随机数在之前抓包工具也能拿到。
所以抓包工具自己就能推导出对称密钥，来解密通信的内容。
所以主要还是信任了抓包工具的证书
#### app防止抓包工具信任证书抓包
那可以app提前内置了服务端的公钥证书，这样在网络请求时就可以匹配是否来自服务器的公钥。

### 输⼊⼀个url，浏览器的执⾏流程？dns流程？

### 断点续传如何实现？秒传？返回什么状态码？
主要是指定header指定range，正常会返回206的响应码
秒传应该是跟MD5有关，比如传MD5给服务器，服务器匹配已有了MD5对应的资源，那么就不需要客户端传了


### WebSocket，讲下它和Http的区别？
http本质上就是一次请求与响应的过程，而websocket可以持久化的双向通讯，
websocket发送完一次http请求后就可以保持连接了，服务器可以推送消息到客户端


### TCP/IP为什么去掉会话层 表现层？
因为会话层、表现层也都是在应用层里面去实现的，这个很难去达到复用的效果或者说抽象出来。
除非每个软件产商自己做一个适用于自己的软件系统的一个会话层和表现层吧。但是本质上也都是在应用层里面，会话层和表现层（框架布局的逻辑排布）看上去更像是一个中间件


### Keep-Alive（长连接） 和非 Keep-Alive（短连接） 区别，对服务器性能有影响吗
如果没有keep-alive的话对于客户端在短时间内发出多个http请求的话，TCP建立连接这些性能开销也比较大。
而开启了keep-alive的话，可能就要注意下alive-timeout吧。
长连接：点对点的、通讯比较频繁的、客户端连接比较少的
短连接：用户量太大的话，用长连接容易被占用资源造成浪费。

### http keep-alive与tcp keep-alive
http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http
tcp的keep-alive检测TCP连接状况的

### HTTP 是不保存状态的协议,如何保存用户状态
采用session会话机制，服务端那边创建一个sessionId给客户端，然后客户端下次在请求打适合在cookie里带上这个sessionId
服务端就能根据这个sessionId查找出之前保存打客户端身份信息。
或者说用cookie也可以。（区别说cookie说把信息保存在客户端打，而session是把信息保存在服务端打）

### 常见错误码
3开头的话就有301 302表示资源被移动，305是必须用代理 307重定向 304表示这次GET请求服务器资源未发生变化，缓存用的
400 Bad Requested 请求参数有误
403 Fortbidden 服务器拒绝
404 Not Found 找不到资源
500 服务器出错（代码出错）
501 502 503 504 505

### TCP 接收方滑动窗口（缓冲区）满了怎么办
此时接收方会把自己打接收窗口大小调到0给发送方，发送方就一直等接收方窗口大小不为0，这时候也会有一个计时器周期性的去试探对方打接收窗口大小。

### 拥塞控制4种方式
慢开始 ：慢慢先开始试探 发1 wind  2wind
拥塞避免：窗口缓慢增长，遇到阻塞的话就缩小一半
快重传：接收方收到错误的数据包就马上回复确认，让发送方尽早的知道这个错误（3次重复确认认为说报文丢失）
快恢复：配合快重传的

### TCP报文包含哪些
源端口和目的端口、序列号、确认字段、首部长度、保留字段、控制位、校验和、数据部分。