# 与选择排序不要混淆
选择排序每次选择一趟都是选出最值来跟前面的交换
而插入排序每次都是拿一个值然后看看适合插入在哪个位置上

# 性质
算法是稳定的
插入排序适用于已经有部分数据已经排好，并且排好的部分越大越好。
时间复杂度 是O(n的3/2次方)

# 代码
```
 public static void sort(Comparable[] a)
    {
        //将a[]按升序排列
        int N=a.length;
        for (int i=1;i<N;i++)
        {
        //将a[i]插入到a[i-1]，a[i-2]，a[i-3]……之中
            for(int j=i;j>0&&(a[j].compareTo(a[j-1])<0);j--)
            {
                Comparable temp=a[j];
                a[j]=a[j-1];
                a[j-1]=temp;
            }
        }
    }

```

# 动画看效果
https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif

# 理解
就是从第二个数据开始，往前面去插。
比如3 44 38 5 8 25 9 6
第一趟选择44往前插 ： 44 3  38 5 8 25 9 6
下一个38往前插：44 38 3  5 8 25 9 6
下一个5往前插：44 38  5 3  8 25 9 6
下一个8往前插：44 38  8 5 3  25 9 6
下一个25往前插：44 38 25 8 5 3  9 6
