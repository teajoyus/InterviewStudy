# 性质
节点i的左孩子是 2* i + 1
右孩子是 2*i + 1 + 2

# 过程
a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序


# 代码解析
第一轮循环：
首先第一轮先确定1个根节点。也就是最大堆的根节点一定是在第一个元素。
对第一个非叶子节点 也就是取中间值，i = arr.length/2 - 1
然后进入堆排序调整。
找到这个i节点的左孩子是 k = 2 * i + 1
判断一下右孩子是不是更大？是的话就指向右孩子 k++
然后进行交换。
交换完毕后再进入左右孩子继续做循环（当然这时候左右孩子都是叶子节点了 就没有了）

第二趟： 把i = arr.length/2 - 1 往前i--继续走上面的直到0
就可以把所有非叶子节点的位置进行调整，得到最大根。
---------------------------
进入第二次循环：
找到最大跟在第一个位置上后，与末尾的元素交换。
其实这个交换的过程只是相当于选择排序一样，得到了一次最大值就跟最后一个交换
然后缩小数组的范围。比如一开始数组是10个，那么第二次参与堆调整就是9个






大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  

小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  

