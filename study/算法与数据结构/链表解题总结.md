# 双指针法
一个slow指针、一个quick指针。quick走在前面，当他们重合的时候可以解决一些问题（注意也可以去循环，到尾了继续回到head）

## 解决场景题

### 是否有环
  快慢指针 走一步 走两步
  
###找中点
  同理
  
### 找环的起点
相遇的时候快指针走的步数2k步，而实际上k就是环的长度】
公式（自己总结）：
假设到环的入口距离是len，在环的相遇点距离环入口是x，环的长度是R
那么slow指针走了K步，就是K = len + x
而quick指针走了2K步，就是2K = 2(len + x) = len + n*R + x (自己画图就可以脑补,可能需要绕多几圈 所以是n*R)
于是有公式： 2(len + x) = len + R + x，简化后就是len + x = n*R
而len + x 是K，也就是K = n*R。
所以走的K步数其实就是R的长度的整数倍。所以让其中一个指针指向头结点 两个指针每次都走1步就会刚好在环的入口相遇
（细思极恐，其实它就是我们快慢指针找中点一样的，相遇的地方其实就是个中点）

### 寻找倒数第k个
让quick指针提前走k个就好了

### 删除倒数第k个
利用《寻找倒数第k个》的解法知道倒数第k个，同时需要记录k个的前一个才好来删除，也注意要判断删除节点是否是头结点

### 两个链表的公共节点
双指针每次都走一步 到头了就继续回到head，总有一天碰到（while(p1!=p2)）


# 借用栈来得到反转（或者递归）

## 场景
### 链表相加（大数加法）
用两个栈遍历记录两个列表，然后分别出栈，累加起来。

### 


# 其它重要场景

## 反转链表
两个指针，另外rev指针记录反转后的链表头，注意rev初始化为head，并且等别的变量拿有head.next后，马上先rev.next = null
这样才是反转后的链表尾部
第二种就是递归，注意递归返回值是反转后头结点，注意last = ReverseList2(head.next); head.next = head.next.next; return last;

## 合并有序链表

第一种常规解法吧。维护几个指针，然后判断哪个大就串联哪个，要注意链表需要断开的问题（断开前记得先记录下一个结点）
第二种是递归。递归返回每次返回最小的结点也就是头结点
查看：com\example\javalib\高频算法题\合并有序链表.java