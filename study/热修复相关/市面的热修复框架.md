# 阿里系

## AndFix
是一种对native层面的hook
利用apkPatch工具将两个apk对比形成一个补丁包，这个补丁包就是那些更改过了的类，这些类也有个后缀来区别于原来的类。
然后修复的方法中会有一个MethodReplace注解，注解指定了className和方法名。表示要修复的方法，
然后再从native层面去hook这个method，会进行方法的替换。（方法指针）
### 不足
方法层面的、不能修复资源、so库之类。也不能新增方法和类。


### 优势
不需要重启

## hotFix
在java层面通过ClassLoader改变加载顺序来实现

采用dex分包、改变dex加载顺序的实现方式。
在ClassLoader里，DexPathList里存着一个节点数组，每一个节点对应了一个Dex，通过合并我们的补丁dex，然后把补丁中的类提到前面来。
这样类加载就变成补丁类
### 难点 - 如果类没有引用另外一个dex包，就会被打上一个标记。
解决方法是：补丁包中的每个类都必须去依赖另外一个dex包的类（使用插桩），来防止被打上标记。比如在构造器里主动调用一下另外一个dex包的类
### 不足
需要重启 不支持资源 so库

## Robust
基于方法插桩的方式来实现
利用gradle脚本，在编译时对每个类插入一个静态变量，然后每个方法插入这个静态变量的静态方法。
这样的话就可以用我们的补丁包来加载出补丁类，来确定方法应不应该走补丁类方法

## tinker
tinker就比较牛逼一点，他们自研了dex的差分包和合成的算法。
然后用差分包与本地dex合成新的一个完整dex包来实现
资源也支持，资源补丁包直接使用文件md5对比来生成   

## 不足
冷启动
合并dex包是在虚拟机堆内存上的 容易OOM。导致合成失败
## 饿了么、蘑菇街、等等

## 资源修复原理
通过hook系统的AssertManager，把所有用到它的地方都替换掉。
然后反射调用方法把我们的资源包加入进来。这样就可以引用到新资源，

## so修复原理
正常来说我们加载so入口都是System.loadLibrary方法来实现。
通过替换掉它来尝试加载指定目录的so，不过这个需要侵入业务代码，有些可能不好改。
另外一种方式可以反射来吧补丁so加载进来，放到数组最前面，跟ClassLoader原理类似的方式。


# 热修复需要注意的问题

- 版本管理 主分支 开发分支 修复分支
- 分发监控，像Sophix、Tinker都有监控（收费）




