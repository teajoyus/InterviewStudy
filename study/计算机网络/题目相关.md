# 一块网卡怎么会知道另一块网卡的 MAC 地址？
通过ARP协议
# MAC地址 (48位)
产商分配的唯一的一个地址，对应一块网卡。
数据从传递到另外一个网卡就需要知道对方的MAC地址。

“原始”方式：采用广播的形式向本网络的所有MAC地址发送数据，让每台计算机自己判断是否需要接收
但是这样的话就很不科学了，这样子在网络上那么多计算机每天都在接收广播，显然是不行的。
所以如果要是知道两台计算机在同个子网络的话就可以用广播的方式，不然的话就可以用路由。

所以就有了网络层，它可以让我们来区分两台计算机是否处在于同一个子网络里。所以没太计算机又有了一个网络地址。
所以也就是有了个IP协议，每个IP地址分为前缀和后缀，前一部分代表网络，后一部分代表主机。
但是前缀的长度并不是固定的，所以我们就需要引入另外一个东西来区分。
所以就有了子网掩码，每个地址通过与子网掩码进行与操作就可以得出所在的子网络
所以IP协议重要的两个就是：1、为每台计算机分配ip地址；2、确定ip地址所在的子网络

而一开始以太网的数据中只存留了MAC的地址栏，并没有存放IP地址的地方。
换句话说，如果新增了IP协议就得需要对底层进行修改了，这样成本也很高，
所以最终的做法是：把IP地址放在数据部分里

## 通常IP是已知的，但是不知道对方的MAC地址
我们需要一种机制，能够从 IP 地址得到 MAC 地址。

如果两台计算机不再同一个子网络，那么也没办法拿到对方的MAC地址。只能把数据包传送给双方的网关，让网关去处理
网关会通过ARP协议来确定是否在本子网络里，如果不是就再继续转发。

第二种情况如果是在同一个子网络里。那么可以用ARP协议，报文中指定要查询的IP地址，对方收到后跟自己的IP比较
一致时就做出回复，向对方报告自身的MAC

## 端口
计算机中同时会有多个进程使用，就必须设定一种标记来做区分，所以就有了端口的分配（16字节）
传输层的功能就是，建立起端口与端口之间的链接，有了IP地址和端口就可以建立起连接。


## TCP
每发出一个包都要确认一下，如果收不到确认，就会重新发送。所以它的效率相对UDP来说是比较低的
TCP没有固定的长度限制，但是一般是不会超过IP数据包的长度，才不会被分割


## DHCP 动态分配


## 浏览器访问谷歌过程
首先我们输入的地址，我们需要先确定谷歌的ip地址是啥
这时候浏览器会通过DNS请求确定谷歌的ip地址
然后我们判断这个地址是不是处于同一个子网络里，通过子网掩码来确定。
发现这个ip不再同个网络，那么就像网关（路由器）转发。
也就是说，接收方的 MAC 地址将是网关的 MAC 地址。
加入我们面向的是HTTP，头部里面就会包含ip地址、版本、各种相关的head。
然后TCP包是需要端口号的，，HTTP端默认的端口号是80。
发送方的自己也会随机生成一个端口号。然后TCP包就封装自己的头部加上HTTP的数据包
然后再IP协议里是需要知道双方的IP地址的。IP包自己也有20字节的头部
然后到以太网的数据包里，以太网是需要设置双方的MAC地址的，同时以太网自己也有8字节的头部
IP地址就被放在了以太网包的数据部分里。如果超过长度会被分段

对方服务器响应。收到以太网的数据包，根据IP把这几个以太网数据包封装起来变成IP包最后变成TCP报文包
然后取出数据部分来读取HTTP协议的内容


# 每一层对应的协议
TCP/IP协议一般是分为四层

应用层：HTTP HTTPS DNS FTP SMTP
传输层：TCP UDP
网络层：IP  ICMP IGMP（ICMP是对IP协议的一个补充，可以回传一些错误报告、或者是询问报告）
数据链路层：ARP RARP

# ping的原理
调用的是ICMP协议（ICMP没经过一个路由会被信息存在报文中）

# IGMP
那些什么单播 组播 广播之类的
跨越路由器之间的组播吧 




