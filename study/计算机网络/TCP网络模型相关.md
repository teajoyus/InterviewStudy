
三次握手博客：https://blog.csdn.net/jun2016425/article/details/81506353
三次握手字段示意图：https://img-blog.csdn.net/20180808105159546
## 三次握手
第一次：客户端发送syn字段（当然还有其他比如seq，此时变成SYN_SEND状态）
第二次：服务端接收到syn字段后，对客户端发送SYN+ACK（ack表示我确认接到你的同步请求了）
第三次：客户端变成连接建立状态，发送ACK给服务器，服务器接收到ACK后也变成建立状态
## SYN flood攻击

攻击方的客户端只发送SYN分节给服务器，然后对服务器发回来的SYN+ACK什么也不做，直接忽略掉，
不发送ACK给服务器；这样就可以占据着服务器的半连接队列的资源，导致正常的客户端连接无法连接上服务器。-----[维基百科]

(SYN flood攻击的方式其实也分两种，第一种，攻击方的客户端一直发送SYN，对于服务器回应的SYN+ACK什么也不做，不回应ACK,。
第二种，攻击方的客户端发送SYN时，将源IP改为一个虚假的IP, 然后服务器将SYN+ACK发送到虚假的IP, 这样当然永远也得不到ACK的回应。)

## 四次挥手

https://blog.csdn.net/whuslei/article/details/6667471
第一次：客户端发送FIN报文（表明自己已经没有任何数据要提交的了）
第二次：服务器发送ACK给客户端（表示我知道了）
第三次：服务器发送FIN报文给客户端（表名自己没有数据要发送了）
第四次：客户端发送ACK，并且进入TIME_WAIT状态。

## 为什么握手三次，挥手需要四次

因为在第二次握手的时候，服务端可以一起把ACK+SYN字段同时发给客户端
但是在挥手的时候，客户端发送FIN报文。服务端只能先发ACK字段，因为它不一定也能及时发出FIN报文（可能还有数据还没发送完毕）
所以ACK和FIN报文就要分两次发。

## 为什么是三次握手需要两次确认（为什么客户端还需要再发一次ACK过去）

考虑一种情况，假如客户端发送的连接报文在某个网络节点卡住了，等到客户端关闭连接了后那个报文还传给了服务端，这时候假如服务端直接ACK后就建立连接的话
而客户端又无连接，这就浪费了服务端的资源了。而假如当客户端在收到ACK后再发出一次ACK确认报文的话，服务端就清楚了客户端的状态。
（自己理解：不过其实，这个东西你也没办法说就保证了服务端不会浪费资源了，假如后面客户端的ACK服务端还是延迟收到了呢，这可以说是一种对可靠性的一种优化，因为通讯信道是不可靠的，没办法保证说双方一定能相互收到报文。
如果说根本不关心可靠性，比如UDP，那就不需要这些握手流程了。
）

## 连接过程各个状态
- LISTEN 服务端监听状态
- CLOSED 初始状态
- SYN_SENT 发送SYN报文状态
- SYN_RCVD  接受到SYN报文
- ESTABLISHED 建立连接

- FIN_WAIT_1 当处于ESTABLISHED状态时，发送完FIN报文就进入这个状态（特别短暂，因为马上就收到ack回应了）
- FIN_WAIT_2 发送FIN报文完后FIN_WAIT_1状态，接收到ack回应后进入FIN_WAIT_2状态

- TIME_WAIT

## TCP和UDP差别
TCP的特点就是可靠性和稳定性，需要经过三次握手后建立连接。而且在传输数据的过程，还有那些超时重传啊、窗口啊、堵塞控制的之类的做法，就是为了对上层应用来提供一个可靠和稳定的传输
每个数据包传输过程都要经过这些确认机制。
而UDP的特点就是快，不需要像TCP一样去建立连接，直接把数据扔给对方，也不搭理对方能不能收到数据。而且报文也要简单一些，不像TCP有那么多同步控制的字段，所以它的传输效率就会更高。

## TCP与UDP的使用场景

根据他们的最大的区别就是一个是稳定可靠的，另外一个是传输效率高的。所以如果说我们的场景是需要保证数据完整性的，比如传输一个文件，一份文档，一个邮件。那就必须用TCP来保证这个完整性了。
但是比如说我们通讯、音视频对话之类的，我们本身传输就特别讲究效率 就是要快，但是又不需要一定得可靠，所以就可以用UDP

## TCP如何保证可靠传输

- 校验和
  对数据包二进制进行相加取反校验，如果收到的数据包再进行这个操作得出的校验和不同 ，那么就丢弃这个数据包也不确认接收这个数据包
  
- 确认应答和序列号
  每个数据报文都有序号，接收放收到报文后也会做出确认应答
  
- 滑动窗口
  为了控制流量，双方都有自己的缓冲区，在报文中也会有滑动窗口的大小来控制双方传输的速率，防止太快来不及处理

- 拥塞控制（慢开始，快恢复 快重传）
 
## 七层网络（OSI网络模型）

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 链路层
- 物理层

## 四/五层网络模型（    TCP/IP模型）
 把应用层、表示层、会话层统称为应用层
 把链路和物理层通常为网络接口层
 现在一般没有七层网络模型，因为表示层和会话层并没有独立开来，都是于应用层在一块的，
 一开始是为了让所有软件能共享会话层 表示层，但是每个软件的需求都不一样，很难去抽象出来这个东西，而且每个软件自己也不好控制。
 我觉得这个东西本质上应该说是一个中间件，可以抽象成一种中间件，符合需求的软件就可以集成这个中间件来减少自己的实现
 
 后面也把安全层加了进来，就是SSL/TLS。那么就多了一层。其实本来就没有所有的HTTPS，只是因为加多了这个东西之后就变成了HTTPS
  
 ## TCP/UDP在哪一层
 
 传输层。TCP提供了可靠的传输，UDP则提供的是不可靠但是效率高的传输