https://segmentfault.com/a/1190000012196642 https

## http 各个状态码含义
2开头一般都是成功处理请求的
3开头是重定向相关的
4开头就是请求错误的，一般来说多是客户端请求有问题
5开头是服务器的错误

## http格式、常用请求头

- Accept 表示客户端可以接收的类型
- User-Agent 用户代理 通过什么工具做请求的
- cookies 

# GET和POST的差别

- 功能上不同
  
  GET本身侧重于是对服务器拿数据，而POST本身是侧重于对服务器发送数据

- 传输形式不同
  
  GET请求的请求数据是放在URL后面的，本质上就是一个URL。
  也因为这样限制了这条URL长度，本身不能超过2KB。所以请求数据如果太大的话就没办法了
  本身HTTP协议对URL长度是没有限制的，但是一些浏览器或者工具对这个长度就是有限制的
  
  而POST请求有单独的请求体，与URL区分开来。一般来说没有这个限制。而且也不会像GET请求一样直接在URL上暴露了请求的数据
  不过他们也都一样POST请求也一样不安全，除非HTTPS
- TCP报文

  GET请求是把header和data一起发的，而POST是先发送header得到100响应后再发送data得到200的响应
  （不过这个跟浏览器或者工具关系更大，不是post本身的必要行为）  
  
## http的优缺点

- 连接简单、无状态的
- 比较灵活，没有太多限制，在报文中可以自己定义很多字段
- 可靠性， http是基于TCP、IP

## SSL / TLS

### 非对称加密

 双方各自生成一对公钥和私钥，私钥自己存放，用来解密对方发来的消息，公钥发送给对方，用来加密要发送的消息。这样即使公钥泄露，他人也无法解密
 值得注意的是：公钥加密后的密文只能通过对应的私钥来解密，而私钥加密的密文却可以通过对应的公钥来解密。
 
 问题：假如公钥在发送过程被中间人劫持了，中间人用自己的公钥发给服务器，然后服务器通过该公钥加密后把消息发出来，中间人用自己的私钥来解密
 所以问题就处在于**如何验证公钥是真的**
 
### 效率问题
由于非对称加密太消耗性能，所以HTTPS通信过程中是用对称解密的，只有认证过程才是非对称加密。
服务器生成一对公钥和私钥、然后把公钥给客户端，客户端通过这个公钥加密它随机生成的对称密钥，服务器再通过私钥来解密这个对称密钥
此后通信就用这个对称密钥来通信了。

### 引入CA机

 因为公钥可能在发送过程被中间人劫持，所以出现了CA机构作为认证中心，服务器会先到CA机构把自己的公钥和其它信息等给CA机构，CA机构再颁发证书给浏览器。
 而浏览器不需要再发公钥给客户端了，而是发这个证书。客户端通过提前内置的CA机构的证书或者是提前安装对应证书，然后客户端查找对应的本地证书，找到CA机构的公钥，就可以正常解密服务器的公钥了。
 （客户端会提前内置CA的根证书，持有CA的公钥）
问题：如果中间人向CA申请了证书，然后劫持服务器的证书，把自己的证书发给客户端，那么这时候服务端就拿到的是中间人的公钥了

### 引入数字签名
 
 数字证书中除了有公钥这些，还包括了证书内容的摘要、签名计算方法、对应的域名等，权威机构用它的私钥来加密得到数字签名
 客户端在收到服务器发来的证书副本后，除了匹配证书内容的有效性，比如过期时间、域名等，还会用本地根证书的CA公钥解密这个数字签名来看是否匹配
 
### 客户端证书
与服务端证书差不多的，就是客户端自己安装证书，比如网上银行就需要客户端证书来鉴别终端身份

## SSL建立连接过程

1、客户端发送一个 Client Hello报文开始SSL通信，报文中包含了加密组件（加密算法、长度等）
然后重点：客户端会附加一个随机数
2、服务端会以Server Hello作为应答，和客户端一样报文也包含了这些加密组件（不同的是服务器是在接收到客户端的加密组件后筛选出来的）
然后重点：服务器也会附加一个随机数
3、之后服务器再发送Certificate报文，该报文就包含了服务器的数字证书（公钥就在里面）
4、服务器再发送一个Server Hello done告知客户端，最初的SSL第一次协商阶段结束
5、客户端对服务器发来的数字证书进行验证，如果验证成功就取出对应的公钥。（用CA公钥来解密这个数字证书的摘要部分，确认信息是否匹配）
6、客户端以Client Key Exchange报文回应，其中包含有一个随机密码串。该报文利用服务器证书里取出来的公钥进行加密
7、客户端继续发送Client Cipher Exchange报文，用于告知服务端，客户端已经切换到之前协商好的加密套件了
8、客户端继续发送finished报文，该报文包含了全部报文的整体校验值，用于给服务端校验完整性
9、服务器收到后，用私钥来进行解密，取出客户端的那个随机密码串，然后服务器也发送Server Cipher Exchange报文
10、服务器同样发送finished报文，也包含了整体校验值，用户给客户端校验
11、finished报文内容交换完毕后，SSL连接就算建立完成了，由此就可以开始应用层协议通信了

### 问题一：为什么后面斗需要发送finished报文

为了验证双方的身份

### 问题二：为什么会产生三个随机数
对于客户端来说，在生成了这个随机密码串后，会结合前面两个随机数来推导出一个master secret
再用master secret推导出一个hash secret和一个session secret。
服务端也是一样这么推导，所以正常情况下他们推导出的值是相同的。
在双方进行对称加密的通信时，用hash secret对报文生成一个摘要，再利用session secret来进行加密
接收方通过session secret解密后，也用hash secret对报文进行一次计算，来匹配摘要验证数据是否被篡改

### 问题三：为什么需要三个随机数，只用一个不行吗

这种会比较靠谱一点，因为计算机中的随机数本质上都是伪随机数，只用一个的话可能很容易被推导。
而用一个客户端的加上一个服务端的，就可以当做真正意义上的随机数了。

另外一个如果建立通信时受到扰乱，比如被恶意重复发送报文，那么也可以通过这个随机数来区分干扰

### 问题四：如果中间人拦截了服务器的证书，并且对证书做了篡改会怎么样？

如果是改证书的内容的话，因为数字签名的存在，客户端可以区分出来。
如果是换掉了数字签名的话，因为黑客自己也不知道CA机构的密钥，所以客户端用CA公钥解密不出来正确的信息
如果说黑客也去同个CA申请了证书，客户端就可以正常解密出来，但是由于绑定的域名等信息不对称，客户端也会产生警告

 
## 抓包工具 charies、Fildder为什么还能抓到https的包

这个前提也是得客户端安装信任抓包工具的证书啊。
抓包工具会把服务端的证书拦截下来，用自己的证书发给客户端，由于客户端已经信任改抓包工具的证书所以验证通过。
然后客户端在生成随机密码串的时候也是用抓包工具的公钥来加密的，而双方的随机数在之前抓包工具也能拿到。
所以抓包工具自己就能推导出对称密钥，来解密通信的内容。
所以主要还是信任了抓包工具的证书

## app防止抓包工具信任证书抓包

那可以app提前内置了服务端的公钥证书，这样在网络请求时就可以匹配是否来自服务器的公钥。



